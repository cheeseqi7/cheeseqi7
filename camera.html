<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>视频通话</title>
    <!-- MediaPipe Selfie Segmentation -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils"></script>
    <!-- PeerJS -->
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <!-- html2canvas -->
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <style>
        @font-face {
            font-family: 'JinnianYaoyoujiaya';
            src: url('今年也要加油鸭.ttf') format('truetype');
        }
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            background-image: url('背景紫色.png');
            font-family: 'JinnianYaoyoujiaya', sans-serif;
        }
        .photo-label, .video-label, .peer-id-label, .weather-display, .weather-display .title, .weather-display .content, 
        .connection-status, .status-container, .copy-tooltip, .peer-input, .call-button, .photo-label {
            font-family: 'JinnianYaoyoujiaya', sans-serif !important;
        }
        .peer-id-container {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 1000;
        }
        .peer-id-label {
            font-size: 14px;
            color: #666;
            margin-bottom: 5px;
        }
        .peer-id {
            display: inline-block;
            padding: 8px 12px;
            background: #f0f0f0;
            color: #333;
            border-radius: 4px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
        }
        .peer-id:hover {
            background: #e0e0e0;
            transform: translateY(-1px);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        .peer-id.copied {
            background: #4CAF50;
            color: white;
        }
        .copy-tooltip {
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .copy-tooltip.show {
            opacity: 1;
        }
        .status-container {
            margin-top: 5px;
            font-size: 12px;
            color: #666;
        }
        .video-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 100%;
            max-width: 1200px;
            padding: 20px;
        }
        .video-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            width: 100%;
            max-width: 1000px;
        }
        .video-wrapper {
            position: relative;
            width: 100%;
            padding-top: 75%;
            background: transparent;
            border-radius: 10px;
        }
        .video-background-emoji {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 120px;
            opacity: 0.6; /* 增加不透明度 */
            z-index: 1; /* 确保在视频层之上 */
            pointer-events: none;
            animation: float 3s ease-in-out infinite;
            background: transparent;
            width: auto;
            height: auto;
            min-width: 120px;
            min-height: 120px;
            display: block; /* 确保元素显示 */
            visibility: visible; /* 确保元素可见 */
        }
        @keyframes float {
            0%, 100% {
                transform: translate(-50%, -50%);
            }
            50% {
                transform: translate(-50%, -55%);
            }
        }
        .video-wrapper video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 0; /* 确保视频在背景emoji之下 */
        }
        .video-wrapper canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0; /* 确保画布在背景emoji之下 */
        }
        .video-wrapper #localVideo {
            display: none; /* 隐藏本地视频元素 */
        }
        .video-label {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 1;
        }
        .controls {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        .control-button {
            padding: 12px 24px;
            background: #1890ff;
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        .control-button:hover {
            background: #40a9ff;
        }
        .control-button:disabled {
            background: #d9d9d9;
            cursor: not-allowed;
        }
        .status {
            margin-top: 10px;
            color: #666;
            font-size: 14px;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        #combinedCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }
        .background-pattern {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: linear-gradient(45deg, #808080 25%, transparent 25%),
                            linear-gradient(-45deg, #808080 25%, transparent 25%),
                            linear-gradient(45deg, transparent 75%, #808080 75%),
                            linear-gradient(-45deg, transparent 75%, #808080 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            opacity: 0.3;
            z-index: 0;
        }
        .status-container {
            margin-top: 15px;
            padding: 12px;
            border-radius: 5px;
            font-size: 14px;
            text-align: center;
            transition: all 0.3s;
        }
        .status-container.connected {
            background-color: #f6ffed;
            color: #52c41a;
            border: 1px solid #b7eb8f;
        }
        .status-container.disconnected {
            background-color: #fff2f0;
            color: #ff4d4f;
            border: 1px solid #ffccc7;
        }
        .status-container.connecting {
            background-color: #e6f7ff;
            color: #1890ff;
            border: 1px solid #91d5ff;
        }
        .call-interface {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-top: 20px;
            padding: 20px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 500px;
        }
        .input-group {
            display: flex;
            gap: 10px;
            width: 100%;
        }
        .peer-input {
            flex: 1;
            padding: 10px;
            border: 1px solid #d9d9d9;
            border-radius: 5px;
            font-size: 16px;
        }
        .peer-input:focus {
            outline: none;
            border-color: #40a9ff;
            box-shadow: 0 0 0 2px rgba(24,144,255,0.2);
        }
        .call-button {
            padding: 10px 20px;
            background: #1890ff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        .call-button:hover {
            background: #40a9ff;
        }
        .call-button:disabled {
            background: #d9d9d9;
            cursor: not-allowed;
        }
        .incoming-call {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            text-align: center;
            z-index: 1000;
        }
        .call-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        .accept-button {
            background: #52c41a;
            color: white;
        }
        .reject-button {
            background: #ff4d4f;
            color: white;
        }
        .accept-button:hover {
            background: #73d13d;
        }
        .reject-button:hover {
            background: #ff7875;
        }
        #localPreview {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 160px;
            height: 120px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 100;
        }
        .photo-frame {
            position: relative;
            width: 800px;
            height: 600px;
            margin: 20px auto;
            background: var(--frame-bg-color, white);
            padding: 20px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            border-radius: 15px;
            overflow: visible;
            position: relative !important;
            overflow: visible !important;
            z-index: 1000 !important;
            border: 8px solid #fff3b0;
            outline: 2px solid #000;
            outline-offset: -2px;
            transition: background-color 0.3s ease;
        }

        .photo-frame-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            border-radius: 15px;
            transition: background-color 0.3s ease;
            pointer-events: none;
        }

        #photoCanvas {
            position: relative;
            z-index: 2;
            width: 100%;
            height: 100%;
            border-radius: 15px;
        }

        .photo-label {
            position: absolute;
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'JinnianYaoyoujiaya', sans-serif;
            font-size: 20px;
            color: #666;
            z-index: 3;
        }

        .capture-button {
            position: absolute;
            bottom: -60px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 3;
        }

        #weather-animations {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 4;
        }

        .background-color-picker {
            position: absolute;
            right: -120px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1001;
            border: 2px solid #000;
        }

        .color-option {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #fff;
            transition: transform 0.2s ease;
        }

        .color-option:hover {
            transform: scale(1.2);
        }

        .color-option.active {
            border: 2px solid #000;
            transform: scale(1.1);
        }

        .color-label {
            font-family: 'JinnianYaoyoujiaya', sans-serif;
            font-size: 14px;
            color: #666;
            text-align: center;
            margin-top: 5px;
        }

        .photo-frame::before {
            content: '';
            position: absolute;
            top: -20px;
            left: -20px;
            right: -20px;
            bottom: -20px;
            background: white;
            z-index: -1;
            border-radius: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            outline: 2px solid #000;
            outline-offset: -2px;
        }

        .photo-frame::after {
            content: '';
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 40px;
            background: #fff3b0;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            z-index: 1001;
            outline: 2px solid #000;
            outline-offset: -2px;
        }

        .photo-frame canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            border-radius: 8px;
            z-index: 1;
            outline: 2px solid #000;
            outline-offset: -2px;
        }

        .weather-cloud {
            position: absolute;
            width: 100px;
            height: 50px;
            background-image: url('多云.PNG');
            background-size: contain;
            background-repeat: no-repeat;
            z-index: 100;
            top: 25%;
            transform: translateY(-50%);
        }

        .weather-rain {
            position: absolute;
            width: 100%;
            height: 50%;
            z-index: 100;
            top: 0;
        }

        .weather-drop {
            position: absolute;
            width: 20px;
            height: 20px;
            background-image: url('rain.png');
            background-size: contain;
            background-repeat: no-repeat;
        }

        .weather-snow {
            position: absolute;
            width: 100%;
            height: 50%;
            z-index: 100;
            top: 0;
        }

        .weather-flake {
            position: absolute;
            width: 20px;
            height: 20px;
            background-size: contain;
            background-repeat: no-repeat;
        }

        .weather-sun {
            position: absolute;
            width: 60px;
            height: 60px;
            background-image: url('太阳.PNG');
            background-size: contain;
            background-repeat: no-repeat;
            z-index: 100;
            top: 25%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* 修改发光太阳动画样式 */
        .glowing-sun {
            position: absolute;
            width: var(--sun-size, 60px);
            height: var(--sun-size, 60px);
            z-index: 100;
            top: 25%;
            left: 50%;
            transform: translate(-50%, -50%);
            animation: pulse 2s ease-in-out infinite;
            filter: blur(0.5px);
        }

        .glowing-sun .sun-core {
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: url('sssun.png');
            background-size: contain;
            background-repeat: no-repeat;
            border-radius: 50%;
            animation: glow 2s ease-in-out infinite;
        }

        .glowing-sun .sun-halo {
            position: absolute;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255,215,0,0.3) 0%, rgba(255,215,0,0) 70%);
            border-radius: 50%;
            animation: breath 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% {
                transform: translate(-50%, -50%) scale(0.9);
            }
            50% {
                transform: translate(-50%, -50%) scale(1.1);
            }
        }

        @keyframes glow {
            0%, 100% {
                filter: brightness(1) drop-shadow(0 0 10px rgba(255,215,0,0.5));
            }
            50% {
                filter: brightness(1.2) drop-shadow(0 0 20px rgba(255,215,0,0.8));
            }
        }

        @keyframes breath {
            0%, 100% {
                opacity: 0.3;
                transform: scale(1);
            }
            50% {
                opacity: 0.8;
                transform: scale(1.2);
            }
        }

        .glowing-sun .light-spot {
            position: absolute;
            width: 10%;
            height: 10%;
            background: radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 70%);
            border-radius: 50%;
            opacity: 0;
            animation: flicker 3s infinite;
        }

        @keyframes flicker {
            0%, 100% {
                opacity: 0;
                transform: scale(1);
            }
            50% {
                opacity: 1;
                transform: scale(1.2);
            }
        }

        /* 添加热浪效果 */
        .glowing-sun::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0) 70%);
            border-radius: 50%;
            animation: heatWave 3s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes heatWave {
            0%, 100% {
                transform: scale(1);
                opacity: 0.1;
            }
            50% {
                transform: scale(1.2);
                opacity: 0.3;
            }
        }

        .weather-sun-emoji {
            position: absolute;
            font-size: 16px;
            z-index: 101;
        }

        .weather-fog {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 50%;
            background-image: url('IMG_8740(1).png');
            background-size: cover;
            background-position: center;
            opacity: 0.7;
            z-index: 90;
            pointer-events: none;
        }
        /* 添加合照取景框太阳动画样式 */
        .photo-frame-sun {
            position: absolute;
            width: 80px;
            height: 80px;
            z-index: 100;
            top: 10%;
            left: 50%;
            transform: translate(-50%, -50%);
            animation: photoFramePulse 2s ease-in-out infinite;
            filter: blur(0.5px);
        }

        .photo-frame-sun .sun-core {
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: url('sssun.png');
            background-size: contain;
            background-repeat: no-repeat;
            border-radius: 50%;
            animation: photoFrameGlow 2s ease-in-out infinite;
        }

        .photo-frame-sun .sun-halo {
            position: absolute;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255,215,0,0.3) 0%, rgba(255,215,0,0) 70%);
            border-radius: 50%;
            animation: photoFrameBreath 2s ease-in-out infinite;
        }

        .falling-sun {
            position: absolute;
            font-size: 24px;
            z-index: 100;
            animation: fall 3s linear infinite;
            opacity: 0;
        }

        @keyframes photoFramePulse {
            0%, 100% {
                transform: translate(-50%, -50%) scale(0.9);
            }
            50% {
                transform: translate(-50%, -50%) scale(1.1);
            }
        }

        @keyframes photoFrameGlow {
            0%, 100% {
                filter: brightness(1) drop-shadow(0 0 10px rgba(255,215,0,0.5));
            }
            50% {
                filter: brightness(1.2) drop-shadow(0 0 20px rgba(255,215,0,0.8));
            }
        }

        @keyframes photoFrameBreath {
            0%, 100% {
                opacity: 0.3;
                transform: scale(1);
            }
            50% {
                opacity: 0.8;
                transform: scale(1.2);
            }
        }

        @keyframes fall {
            0% {
                transform: translateY(-100px) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(600px) rotate(360deg);
                opacity: 0;
            }
        }

        /* 添加天气emoji动画样式 */
        .falling-emoji {
            position: absolute;
            font-size: 24px;
            z-index: 1000;
            pointer-events: none;
            top: -50px;
            transition: all 8s cubic-bezier(0.4, 0, 0.2, 1);
            transform-origin: center;
        }

        @keyframes rotate {
            from {
                transform: rotate(0deg);
            }
            to {
                transform: rotate(360deg);
            }
        }

        .earth-button {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 80px;
            height: 80px;
            background-image: url('地球.png');
            background-size: contain;
            background-repeat: no-repeat;
            cursor: pointer;
            z-index: 1000;
            border: none;
            background-color: transparent;
            padding: 0;
            margin: 0;
            outline: none;
        }

        .earth-button:hover {
            opacity: 0.8;
        }
        .capture-button {
            position: absolute;
            bottom: -60px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: white;
            border: 4px solid #f0f0f0;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #8a2be2;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .capture-button:hover {
            transform: translateX(-50%) scale(1.1);
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            background: #f8f8f8;
        }
        .capture-button:active {
            transform: translateX(-50%) scale(0.95);
            background: #f0f0f0;
        }

        .photo-label {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(255,243,176,0.9);
            color: #ffb700;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 1;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            outline: 2px solid #000;
            outline-offset: -2px;
        }

        .home-button {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 50px;
            height: 50px;
            background-image: url('地球.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            cursor: pointer;
            z-index: 1000;
            transition: transform 0.3s ease;
        }
        .home-button:hover {
            transform: scale(1.1);
        }

        .weather-display {
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            color: #8a2be2;  /* 紫色 */
            padding: 12px 15px;
            border-radius: 15px;
            font-size: 14px;
            z-index: 10;
            min-width: 120px;
            pointer-events: none;
            border: 2px solid #9370db;  /* 中等紫色 */
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            font-family: 'Arial Rounded MT Bold', 'Arial', sans-serif;
            backdrop-filter: blur(5px);
        }
        .weather-display.local {
            top: 20px;
            left: 20px;
        }
        .weather-display.remote {
            top: 20px;
            right: 20px;
        }
        .weather-display .title {
            font-weight: bold;
            margin-bottom: 5px;
            border-bottom: 2px dashed #9370db;  /* 中等紫色 */
            padding-bottom: 5px;
            color: #8a2be2;  /* 紫色 */
        }
        .weather-display .content {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .weather-display .content div {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .weather-info {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 12px 20px;
            border-radius: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 15px;
            font-family: 'Arial Rounded MT Bold', 'Arial', sans-serif;
            border: 2px solid #ffb6c1;
        }
        .weather-info span {
            font-size: 18px;
            color: #ff69b4;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
        }
        .weather-info .local-weather {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .weather-info .remote-weather {
            display: flex;
            align-items: center;
            gap: 8px;
            padding-left: 15px;
            border-left: 2px dashed #ffb6c1;
        }
        .weather-info .weather-emoji {
            font-size: 24px;
            animation: float 2s ease-in-out infinite;
        }
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-5px); }
            100% { transform: translateY(0px); }
        }
        /* 添加拍照相关的样式 */
        .photo-preview {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
            display: none;
        }
        
        .photo-preview img {
            max-width: 300px;
            max-height: 300px;
            border-radius: 5px;
        }
        
        .photo-preview-buttons {
            display: flex;
            justify-content: space-around;
            margin-top: 15px;
        }
        
        .photo-preview-buttons button {
            padding: 8px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'JinnianYaoyoujiaya', sans-serif;
        }
        
        .photo-preview-buttons .save-btn {
            background: #4CAF50;
            color: white;
        }
        
        .photo-preview-buttons .cancel-btn {
            background: #f44336;
            color: white;
        }
        
        .photo-preview-buttons .retry-btn {
            background: #2196F3;
            color: white;
        }
        
        .capture-countdown {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 999;
            display: none;
        }
        
        .capture-success {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #4CAF50;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            display: none;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <button class="earth-button" title="返回首页" onclick="window.location.href='home.html'"></button>
    <div class="video-container">
        <div class="photo-frame" id="photoFrame">
            <canvas id="photoCanvas"></canvas>
            <div class="photo-label">合照取景框</div>
            <button class="capture-button" id="captureButton" title="拍照" onclick="capturePhoto()"></button>
            <div id="weather-animations" style="position:absolute; top:0; pointer-events:none; z-index:999"></div>
            <div class="loading-overlay" id="loadingOverlay">
                <div class="loading-spinner"></div>
            </div>
            <div class="background-color-picker">
                <div class="color-option" style="background: #ffffff;" data-color="#ffffff" onclick="changeBackgroundColor('#ffffff')"></div>
                <div class="color-option" style="background: #fff3b0;" data-color="#fff3b0" onclick="changeBackgroundColor('#fff3b0')"></div>
                <div class="color-option" style="background: #e6f7ff;" data-color="#e6f7ff" onclick="changeBackgroundColor('#e6f7ff')"></div>
                <div class="color-option" style="background: #f6ffed;" data-color="#f6ffed" onclick="changeBackgroundColor('#f6ffed')"></div>
                <div class="color-option" style="background: #fff0f6;" data-color="#fff0f6" onclick="changeBackgroundColor('#fff0f6')"></div>
                <div class="color-option" style="background: #f9f0ff;" data-color="#f9f0ff" onclick="changeBackgroundColor('#f9f0ff')"></div>
                <div class="color-label">背景颜色</div>
            </div>
        </div>
        <div class="video-grid">
            <div class="video-wrapper">
                <div class="background-pattern"></div>
                <video id="localVideo" autoplay playsinline></video>
                <canvas id="outputCanvas"></canvas>
                <div class="video-label">本地视频</div>
            </div>
            <div class="video-wrapper">
                <video id="remoteVideo" autoplay playsinline></video>
                <div class="video-label">远程视频</div>
            </div>
        </div>
        <div class="call-interface">
            <div class="input-group">
                <input type="text" class="peer-input" id="peerInput" placeholder="输入对方PEER-ID">
                <button class="call-button" id="callButton">呼叫</button>
            </div>
        </div>
        <div class="controls">
            <button class="control-button" id="joinButton">加入通话</button>
            <button class="control-button" id="leaveButton" disabled>离开通话</button>
        </div>
        <div class="status" id="status">等待加入通话...</div>
    </div>

    <!-- PEER-ID显示容器 -->
    <div class="peer-id-container">
        <div class="peer-id-label">PEER-ID</div>
        <div class="peer-id" id="peerId">PEER-XXXX</div>
        <div class="copy-tooltip" id="copyTooltip">已复制到剪贴板</div>
        <div class="status-container" id="connectionStatus">正在连接服务器...</div>
    </div>

    <script src="https://cdn.agora.io/sdk/release/AgoraRTC_N.js"></script>
    <script>
        // 城市代码映射数据（示例数据，实际使用时需要完整的数据集）
        const cityCodeMap = [
            { code: '101010100', name: '北京', lat: 39.9042, lng: 116.4074 },
            { code: '101020100', name: '上海', lat: 31.2304, lng: 121.4737 },
            { code: '101280101', name: '广州', lat: 23.1291, lng: 113.2644 },
            { code: '101280601', name: '深圳', lat: 22.5431, lng: 114.0579 },
            { code: '101210101', name: '杭州', lat: 30.2741, lng: 120.1551 },
            { code: '101190101', name: '南京', lat: 32.0603, lng: 118.7969 },
            { code: '101200101', name: '武汉', lat: 30.5928, lng: 114.3055 },
            { code: '101230101', name: '福州', lat: 26.0745, lng: 119.2965 },
            { code: '101270101', name: '成都', lat: 30.5728, lng: 104.0668 },
            { code: '101110101', name: '西安', lat: 34.3416, lng: 108.9398 }
        ];

        // 根据经纬度获取最近的城市代码
        function getCityCodeByLocation(latitude, longitude) {
            let minDistance = Infinity;
            let nearestCity = null;

            // 计算每个城市与目标位置的距离
            for (const city of cityCodeMap) {
                const distance = Math.sqrt(
                    Math.pow(city.lat - latitude, 2) + 
                    Math.pow(city.lng - longitude, 2)
                );
                
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestCity = city;
                }
            }

            return nearestCity ? nearestCity.code : '101280101'; // 默认返回广州的代码
        }

        // 修改天气查询函数
        async function getWeather(latitude, longitude) {
            const API_KEY = '4a20f5eecda84f57a77135132251604';
            const url = `https://api.weatherapi.com/v1/current.json?key=${API_KEY}&q=${latitude},${longitude}&lang=zh`;
            
            try {
                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json'
                    },
                    mode: 'cors'
                });

                if (!response.ok) {
                    throw new Error(`天气数据获取失败: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();
                
                // 验证必要字段
                if (!data.current || !data.location) {
                    throw new Error('天气数据格式错误');
                }
                
                // 转换WeatherAPI数据格式以匹配原有结构
                return {
                    temperature: data.current.temp_c + '℃',
                    description: data.current.condition.text,
                    humidity: data.current.humidity + '%',
                    windSpeed: data.current.wind_kph / 3.6 // 转换为m/s
                };
            } catch (error) {
                console.error('获取天气信息失败:', error);
                // 返回默认天气信息
                return {
                    temperature: '25℃',
                    description: '晴',
                    humidity: '50%',
                    windSpeed: 3
                };
            }
        }

        // 生成随机字母
        function getRandomLetter() {
            const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            return letters.charAt(Math.floor(Math.random() * letters.length));
        }

        // 生成 PEER-ID
        function generatePeerId() {
            let id = 'PEER-';
            for (let i = 0; i < 4; i++) {
                id += getRandomLetter();
            }
            return id;
        }

        // 复制到剪贴板
        function copyToClipboard(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
        }

        // 初始化 PEER-ID
        const peerId = generatePeerId();
        const peerIdElement = document.getElementById('peerId');
        const copyTooltip = document.getElementById('copyTooltip');
        const connectionStatus = document.getElementById('connectionStatus');

        peerIdElement.textContent = peerId;

        // 添加点击复制功能
        peerIdElement.addEventListener('click', () => {
            copyToClipboard(peerId);
            peerIdElement.classList.add('copied');
            copyTooltip.classList.add('show');
            
            setTimeout(() => {
                peerIdElement.classList.remove('copied');
                copyTooltip.classList.remove('show');
            }, 2000);
        });

        // 创建 Peer 对象
        const peer = new Peer(peerId, {
            host: '0.peerjs.com',
            port: 443,
            secure: true,
            debug: 3,
            config: {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun2.l.google.com:19302' }
                ],
                sdpSemantics: 'unified-plan',
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require',
                iceCandidatePoolSize: 10
            },
            constraints: {
                video: {
                    width: { ideal: 1280 },
                    height: { ideal: 720 },
                    frameRate: { ideal: 30 },
                    facingMode: { ideal: 'user' }
                },
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true
                }
            }
        });

        // 添加数据通道变量
        let dataChannel = null;
        let remoteWeatherData = null;
        let weatherDataConnection = null;
        let isConnectionEstablished = false;

        // 添加发送天气数据的函数
        async function sendWeatherData() {
            if (!weatherDataConnection || !weatherDataConnection.open) {
                console.log('数据通道未建立，无法发送天气数据');
                return;
            }

            try {
                const geoData = JSON.parse(localStorage.getItem('geoData'));
                if (geoData) {
                    console.log('获取本地地理位置:', geoData);
                    const weather = await getWeather(geoData.latitude, geoData.longitude);
                    if (weather) {
                        const weatherData = {
                            type: 'weather',
                            temperature: weather.temperature,
                            description: weather.description,
                            humidity: weather.humidity,
                            windSpeed: weather.windSpeed
                        };
                        console.log('准备发送天气数据:', weatherData);
                        weatherDataConnection.send(JSON.stringify(weatherData));
                        console.log('已发送本地天气信息');
                    } else {
                        console.error('获取天气信息失败');
                    }
                } else {
                    console.error('未找到地理位置信息');
                }
            } catch (error) {
                console.error('发送天气数据时发生错误:', error);
            }
        }

        // 获取DOM元素
        const peerInput = document.getElementById('peerInput');
        const callButton = document.getElementById('callButton');
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const localPreview = document.createElement('canvas');
        localPreview.id = 'localPreview';
        document.body.appendChild(localPreview);

        // 创建用于抠图处理的视频元素
        const processingVideo = document.createElement('video');
        processingVideo.autoplay = true;
        processingVideo.playsInline = true;
        processingVideo.style.display = 'none'; // 隐藏处理用的视频元素
        document.body.appendChild(processingVideo);

        // 创建组合画布用于传输
        const combinedCanvas = document.createElement('canvas');
        combinedCanvas.id = 'combinedCanvas';
        document.querySelector('.video-wrapper').appendChild(combinedCanvas);

        // 初始化本地视频流
        let localStream;
        let videoOnlyStream;
        let audioStream;
        let processedLocalStream;
        async function initLocalStream() {
            try {
                // 检测设备类型
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                
                // 获取设备信息
                const deviceInfo = {
                    isMobile,
                    isFrontCamera: false,
                    isExternalCamera: false
                };

                // 检查是否有外接摄像头
                if (videoDevices.length > 1) {
                    deviceInfo.isExternalCamera = true;
                }

                // 获取视频约束
                const videoConstraints = {
                    width: { ideal: 320 },
                    height: { ideal: 240 },
                    frameRate: { ideal: 10 }
                };

                // 根据设备类型设置摄像头
                if (isMobile) {
                    // 手机设备，优先使用前置摄像头
                    videoConstraints.facingMode = { ideal: 'user' };
                    deviceInfo.isFrontCamera = true;
                } else if (deviceInfo.isExternalCamera) {
                    // 外接摄像头，通过facingMode检测
                    videoConstraints.facingMode = { ideal: 'environment' };
                    deviceInfo.isFrontCamera = false;
                } else {
                    // 电脑内置摄像头
                    deviceInfo.isFrontCamera = false;
                }

                // 先只请求视频权限
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    video: videoConstraints
                });

                // 设置视频元素的镜像和缩放
                if (deviceInfo.isFrontCamera) {
                    localVideo.style.transform = 'scaleX(-1) scale(0.8)';
                    localVideo.mirrored = true;
                } else {
                    localVideo.style.transform = 'scale(1)';
                    localVideo.mirrored = false;
                }

                // 创建只包含视频轨道的流用于抠图处理
                videoOnlyStream = new MediaStream();
                const videoTrack = localStream.getVideoTracks()[0];
                videoOnlyStream.addTrack(videoTrack);
                
                // 添加视频轨道状态日志
                console.log('Video Track Status:', {
                    kind: videoTrack.kind,
                    readyState: videoTrack.readyState,
                    enabled: videoTrack.enabled,
                    muted: videoTrack.muted,
                    label: videoTrack.label,
                    deviceInfo
                });

                // 使用videoOnlyStream进行抠图处理
                processingVideo.srcObject = videoOnlyStream;
                
                // 开始处理本地视频帧
                processingVideo.onloadedmetadata = () => {
                    processFrame();
                };

                // 等待视频处理正常运行后请求音频权限
                setTimeout(async () => {
                    try {
                        // 创建新的音频流
                        audioStream = await navigator.mediaDevices.getUserMedia({ 
                            audio: {
                                echoCancellation: true,
                                noiseSuppression: true,
                                autoGainControl: true
                            }
                        });
                        
                        // 创建新的传输流
                        const transmissionStream = new MediaStream();
                        
                        // 添加音频轨道
                        const audioTracks = audioStream.getAudioTracks();
                        console.log('Audio Tracks:', audioTracks.length);
                        audioTracks.forEach(track => {
                            console.log('Audio Track:', {
                                kind: track.kind,
                                enabled: track.enabled,
                                muted: track.muted,
                                readyState: track.readyState
                            });
                            transmissionStream.addTrack(track);
                        });
                        
                        // 设置用于传输的视频元素
                        localVideo.srcObject = transmissionStream;
                        
                        // 等待处理后的视频流准备好
                        const checkProcessedStream = setInterval(() => {
                            if (processedLocalStream) {
                                // 添加处理后的视频轨道
                                const videoTracks = processedLocalStream.getVideoTracks();
                                console.log('Processed Video Tracks:', videoTracks.length);
                                videoTracks.forEach(track => {
                                    console.log('Processed Video Track:', {
                                        kind: track.kind,
                                        enabled: track.enabled,
                                        muted: track.muted,
                                        readyState: track.readyState
                                    });
                                    transmissionStream.addTrack(track);
                                });
                                clearInterval(checkProcessedStream);
                                console.log('Audio and processed video tracks added successfully');
                            }
                        }, 100);
                        
                    } catch (err) {
                        console.error('无法获取麦克风权限:', err);
                        updateStatus('无法访问麦克风');
                    }
                }, 2000); // 等待2秒确保视频处理稳定
            } catch (err) {
                console.error('无法获取摄像头权限:', err);
                updateStatus('无法访问摄像头');
            }
        }

        // 处理视频帧
        let lastProcessTime = 0;
        const PROCESS_INTERVAL = 100; // 降低处理间隔
        let isProcessing = false;

        async function processFrame() {
            if (!processingVideo.videoWidth || isProcessing) return;

            const now = Date.now();
            if (now - lastProcessTime < PROCESS_INTERVAL) {
                requestAnimationFrame(processFrame);
                return;
            }

            isProcessing = true;
            lastProcessTime = now;

            try {
                // 设置画布尺寸
                const videoWrapper = outputCanvas.parentElement;
                outputCanvas.width = videoWrapper.offsetWidth;
                outputCanvas.height = videoWrapper.offsetHeight;

                // 绘制视频到画布
                const ctx = outputCanvas.getContext('2d');
                ctx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
                ctx.save();
                if (localVideo.mirrored) {
                    ctx.translate(outputCanvas.width, 0);
                    ctx.scale(-1, 1);
                }
                ctx.drawImage(processingVideo, 0, 0, outputCanvas.width, outputCanvas.height);
                ctx.restore();

                // 发送到本地 MediaPipe 处理
                await localSelfieSegmentation.send({ image: outputCanvas });
            } catch (error) {
                console.error('处理本地视频帧失败:', error);
            } finally {
                isProcessing = false;
                requestAnimationFrame(processFrame);
            }
        }

        // 设置媒体流约束
        const mediaConstraints = {
            video: {
                width: { ideal: 1280 },
                height: { ideal: 720 },
                frameRate: { ideal: 30 },
                facingMode: { ideal: 'user' }
            },
            audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true
            }
        };

        // 设置带宽自适应
        function setupBandwidthAdaptation(stream) {
            const videoTrack = stream.getVideoTracks()[0];
            if (videoTrack) {
                // 等待连接建立后再设置带宽自适应
                const checkConnection = setInterval(() => {
                    if (peer.connection) {
                        const sender = peer.connection.getSenders().find(s => s.track === videoTrack);
                        if (sender) {
                            const parameters = sender.getParameters();
                            if (!parameters.encodings) {
                                parameters.encodings = [{}];
                            }
                            parameters.encodings[0].maxBitrate = 2500000; // 2.5 Mbps
                            parameters.encodings[0].maxFramerate = 30;
                            parameters.encodings[0].scaleResolutionDownBy = 1.0;
                            sender.setParameters(parameters).catch(err => {
                                console.error('设置编码参数失败:', err);
                            });
                        }
                        clearInterval(checkConnection);
                    }
                }, 100);
            }
        }

        // 修改发起呼叫的处理
        callButton.addEventListener('click', async () => {
            const peerId = peerInput.value.trim();
            if (!peerId) {
                updateStatus('请输入对方PEER-ID');
                return;
            }

            try {
                console.log('开始呼叫流程...');
                
                // 等待处理后的视频流就绪
                if (!processedLocalStream) {
                    updateStatus('正在处理视频流...');
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    if (!processedLocalStream) {
                        throw new Error('视频流处理失败');
                    }
                }

                // 创建新的传输流
                const transmissionStream = new MediaStream();
                
                // 添加音频轨道
                if (audioStream) {
                    audioStream.getAudioTracks().forEach(track => {
                        transmissionStream.addTrack(track);
                    });
                }
                
                // 添加处理后的视频轨道
                processedLocalStream.getVideoTracks().forEach(track => {
                    transmissionStream.addTrack(track);
                });

                // 设置带宽自适应
                setupBandwidthAdaptation(transmissionStream);

                // 发起呼叫
                console.log('正在发起呼叫...');
                const call = peer.call(peerId, transmissionStream);

                // 创建数据通道
                console.log('正在创建数据通道...');
                weatherDataConnection = peer.connect(peerId, {
                    metadata: { type: 'weather' },
                    reliable: true
                });

                // 设置数据通道事件处理
                weatherDataConnection.on('open', () => {
                    console.log('Weather data connection opened');
                    const localWeather = document.querySelector('#local-weather').textContent;
                    const remoteWeather = document.querySelector('#remote-weather').textContent;
                    
                    // Update weather background
                    updateWeatherBackground(localWeather, remoteWeather);
                    
                    // Start falling emojis
                    startFallingEmojis(localWeather, remoteWeather);
                });

                weatherDataConnection.on('data', (data) => {
                    try {
                        console.log('收到原始数据:', data);
                        let weatherData;
                        if (data instanceof ArrayBuffer) {
                            const decoder = new TextDecoder();
                            const text = decoder.decode(data);
                            console.log('转换后的数据:', text);
                            weatherData = JSON.parse(text);
                        } else {
                            weatherData = JSON.parse(data);
                        }
                        console.log('解析后的天气数据:', weatherData);
                        if (weatherData.type === 'weather') {
                            remoteWeatherData = weatherData;
                            console.log('更新远程天气显示:', weatherData);
                            
                            // 获取本地天气描述
                            const localWeatherDisplay = document.querySelector('.weather-display.local .description');
                            if (localWeatherDisplay) {
                                const localWeatherText = localWeatherDisplay.textContent.replace('天气: ', '');
                                console.log('开始合并显示天气emoji:', { local: localWeatherText, remote: weatherData.description });
                                // 确保在更新emoji之前不会清除现有的emoji
                                const existingEmojis = document.querySelectorAll('.falling-emoji');
                                if (existingEmojis.length === 0) {
                                    startFallingEmojis(localWeatherText, weatherData.description);
                                }
                            }
                        }
                    } catch (error) {
                        console.error('解析远程天气数据失败:', error);
                    }
                });

                weatherDataConnection.on('error', (error) => {
                    console.error('数据通道错误:', error);
                });

                weatherDataConnection.on('close', () => {
                    console.log('数据通道已关闭');
                    weatherDataConnection = null;
                    isConnectionEstablished = false;
                    // 更新天气显示
                    updateWeatherDisplay(false);
                });

                // 设置呼叫处理
                call.on('stream', async (remoteStream) => {
                    console.log('收到远程视频流');
                    // 处理远程视频流
                    console.log('收到远程流:', {
                        audioTracks: remoteStream.getAudioTracks().length,
                        videoTracks: remoteStream.getVideoTracks().length
                    });

                    // 获取当前天气状态
                    const localWeatherDisplay = document.querySelector('.weather-display.local .description');
                    const remoteWeatherDisplay = document.querySelector('.weather-display.remote .description');
                    const myWeather = localWeatherDisplay ? localWeatherDisplay.textContent.replace('天气: ', '') : '未知';
                    const partnerWeather = remoteWeatherDisplay ? remoteWeatherDisplay.textContent.replace('天气: ', '') : '未知';
                    console.log('连接成功，当前天气状态：', { myWeather, partnerWeather });

                    // 移除所有现有的远程视频元素
                    const videoGrid = document.querySelector('.video-grid');
                    const remoteWrappers = videoGrid.querySelectorAll('.video-wrapper:not(:first-child)');
                    remoteWrappers.forEach(wrapper => wrapper.remove());

                    // 创建新的视频元素
                    const newRemoteVideo = document.createElement('video');
                    newRemoteVideo.autoplay = true;
                    newRemoteVideo.muted = false;
                    newRemoteVideo.playsInline = true;
                    newRemoteVideo.srcObject = remoteStream;
                    
                    // 创建新的画布元素用于抠图
                    const newOutputCanvas = document.createElement('canvas');
                    newOutputCanvas.id = 'remoteOutputCanvas';
                    const newCtx = newOutputCanvas.getContext('2d');
                    
                    // 创建视频标签
                    const videoLabel = document.createElement('div');
                    videoLabel.className = 'video-label';
                    videoLabel.textContent = '远程用户';
                    
                    // 创建视频包装器
                    const videoWrapper = document.createElement('div');
                    videoWrapper.className = 'video-wrapper';
                    videoWrapper.appendChild(newRemoteVideo);
                    videoWrapper.appendChild(newOutputCanvas);
                    videoWrapper.appendChild(videoLabel);
                    
                    // 添加到视频网格
                    videoGrid.appendChild(videoWrapper);
                    
                    // 设置画布尺寸
                    function setRemoteCanvasSize() {
                        newOutputCanvas.width = videoWrapper.offsetWidth;
                        newOutputCanvas.height = videoWrapper.offsetHeight;
                        console.log('设置远程画布尺寸:', {
                            width: newOutputCanvas.width,
                            height: newOutputCanvas.height
                        });
                    }
                    
                    // 开始处理远程视频帧
                    newRemoteVideo.onloadedmetadata = () => {
                        setRemoteCanvasSize();
                        
                        // 使用 requestAnimationFrame 处理视频帧
                        function processFrame() {
                            if (newRemoteVideo.readyState === 4) {
                                processRemoteFrame();
                            }
                            requestAnimationFrame(processFrame);
                        }
                        
                        requestAnimationFrame(processFrame);
                    };

                    // 确保天气显示和emoji动画继续显示
                    setTimeout(() => {
                        console.log('重新初始化天气显示和emoji动画');
                        // 获取本地天气描述
                        const localWeatherDisplay = document.querySelector('.weather-display.local .description');
                        if (localWeatherDisplay) {
                            const localWeatherText = localWeatherDisplay.textContent.replace('天气: ', '');
                            // 检查是否已经有emoji在显示
                            const existingEmojis = document.querySelectorAll('.falling-emoji');
                            if (existingEmojis.length === 0) {
                                if (remoteWeatherData) {
                                    console.log('合并显示本地和远程天气emoji');
                                    startFallingEmojis(localWeatherText, remoteWeatherData.description);
                                } else {
                                    console.log('显示本地天气emoji');
                                    startFallingEmojis(localWeatherText);
                                }
                            } else {
                                console.log('已有emoji在显示，跳过重新初始化');
                            }
                        }
                    }, 1000);
                    
                    updateStatus('已连接');
                });

                call.on('close', () => {
                    console.log('呼叫已关闭');
                    // 关闭数据通道
                    if (weatherDataConnection) {
                        weatherDataConnection.close();
                        weatherDataConnection = null;
                    }
                    isConnectionEstablished = false;
                    // 移除所有远程视频元素
                    const videoGrid = document.querySelector('.video-grid');
                    const remoteWrappers = videoGrid.querySelectorAll('.video-wrapper:not(:first-child)');
                    remoteWrappers.forEach(wrapper => wrapper.remove());
                    
                    // 重新启用呼叫按钮
                    callButton.disabled = false;
                    updateStatus('通话已结束');
                    // 更新天气显示
                    updateWeatherDisplay(false);
                });

                call.on('error', (err) => {
                    console.error('呼叫错误:', err);
                    // 重新启用呼叫按钮
                    callButton.disabled = false;
                    updateStatus('呼叫失败: ' + err.message);
                    // 更新天气显示
                    updateWeatherDisplay(false);
                });

                // 禁用呼叫按钮
                callButton.disabled = true;
                updateStatus('正在呼叫...');

            } catch (err) {
                console.error('呼叫失败:', err);
                // 重新启用呼叫按钮
                callButton.disabled = false;
                updateStatus('呼叫失败: ' + err.message);
            }
        });

        // 修改接听来电的处理
        peer.on('call', async (call) => {
            console.log('收到来电');
            updateStatus('收到来电');
            
            // 等待处理后的视频流就绪
            if (!processedLocalStream) {
                updateStatus('正在处理视频流...');
                await new Promise(resolve => setTimeout(resolve, 1000));
                if (!processedLocalStream) {
                    updateStatus('视频流处理失败，无法接听');
                    return;
                }
            }

            // 创建新的传输流
            const transmissionStream = new MediaStream();
            
            // 添加音频轨道
            if (audioStream) {
                audioStream.getAudioTracks().forEach(track => {
                    transmissionStream.addTrack(track);
                });
            }
            
            // 添加处理后的视频轨道
            processedLocalStream.getVideoTracks().forEach(track => {
                transmissionStream.addTrack(track);
            });

            // 设置带宽自适应
            setupBandwidthAdaptation(transmissionStream);

            // 接听来电
            call.answer(transmissionStream);

            // 创建数据通道
            console.log('正在创建数据通道...');
            weatherDataConnection = peer.connect(call.peer, {
                metadata: { type: 'weather' },
                reliable: true
            });

            // 设置数据通道事件处理
            weatherDataConnection.on('open', () => {
                console.log('数据通道已建立');
                isConnectionEstablished = true;
                // 发送天气数据
                sendWeatherData();
            });

            weatherDataConnection.on('data', (data) => {
                try {
                    console.log('收到原始数据:', data);
                    let weatherData;
                    if (data instanceof ArrayBuffer) {
                        const decoder = new TextDecoder();
                        const text = decoder.decode(data);
                        console.log('转换后的数据:', text);
                        weatherData = JSON.parse(text);
                    } else {
                        weatherData = JSON.parse(data);
                    }
                    console.log('解析后的天气数据:', weatherData);
                    if (weatherData.type === 'weather') {
                        remoteWeatherData = weatherData;
                        console.log('更新远程天气显示:', weatherData);
                        // 立即更新天气显示
                        const remoteWeatherDisplay = document.querySelector('.weather-display.remote');
                        if (remoteWeatherDisplay) {
                            remoteWeatherDisplay.querySelector('.temperature').textContent = `温度: ${weatherData.temperature}`;
                            remoteWeatherDisplay.querySelector('.description').textContent = `天气: ${weatherData.description}`;
                            remoteWeatherDisplay.querySelector('.humidity').textContent = `湿度: ${weatherData.humidity}`;
                            remoteWeatherDisplay.querySelector('.wind').textContent = `风速: ${weatherData.windSpeed} m/s`;
                        }
                    } else {
                        console.log('收到非天气数据:', weatherData);
                    }
                } catch (error) {
                    console.error('解析远程天气数据失败:', error);
                }
            });

            weatherDataConnection.on('error', (error) => {
                console.error('数据通道错误:', error);
            });

            weatherDataConnection.on('close', () => {
                console.log('数据通道已关闭');
                weatherDataConnection = null;
                isConnectionEstablished = false;
            });

            // 设置呼叫处理
            call.on('stream', (remoteStream) => {
                console.log('收到远程视频流');
                // 移除所有现有的远程视频元素
                const videoGrid = document.querySelector('.video-grid');
                const remoteWrappers = videoGrid.querySelectorAll('.video-wrapper:not(:first-child)');
                remoteWrappers.forEach(wrapper => wrapper.remove());

                // 创建新的视频元素
                const newRemoteVideo = document.createElement('video');
                newRemoteVideo.autoplay = true;
                newRemoteVideo.muted = false;
                newRemoteVideo.playsInline = true;
                newRemoteVideo.srcObject = remoteStream;
                
                // 创建新的画布元素用于抠图
                const newOutputCanvas = document.createElement('canvas');
                newOutputCanvas.id = 'remoteOutputCanvas';
                const newCtx = newOutputCanvas.getContext('2d');
                
                // 创建视频标签
                const videoLabel = document.createElement('div');
                videoLabel.className = 'video-label';
                videoLabel.textContent = '远程用户';
                
                // 创建视频包装器
                const videoWrapper = document.createElement('div');
                videoWrapper.className = 'video-wrapper';
                videoWrapper.appendChild(newRemoteVideo);
                videoWrapper.appendChild(newOutputCanvas);
                videoWrapper.appendChild(videoLabel);
                
                // 添加到视频网格
                videoGrid.appendChild(videoWrapper);
                
                // 设置画布尺寸
                function setRemoteCanvasSize() {
                    newOutputCanvas.width = videoWrapper.offsetWidth;
                    newOutputCanvas.height = videoWrapper.offsetHeight;
                    console.log('设置远程画布尺寸:', {
                        width: newOutputCanvas.width,
                        height: newOutputCanvas.height
                    });
                }
                
                // 开始处理远程视频帧
                newRemoteVideo.onloadedmetadata = () => {
                    setRemoteCanvasSize();
                    
                    // 使用 requestAnimationFrame 处理视频帧
                    function processFrame() {
                        if (newRemoteVideo.readyState === 4) {
                            processRemoteFrame();
                        }
                        requestAnimationFrame(processFrame);
                    }
                    
                    requestAnimationFrame(processFrame);
                };

                // 确保天气显示和emoji动画继续显示
                setTimeout(() => {
                    console.log('重新初始化天气显示和emoji动画');
                    // 获取本地天气描述
                    const localWeatherDisplay = document.querySelector('.weather-display.local .description');
                    if (localWeatherDisplay) {
                        const localWeatherText = localWeatherDisplay.textContent.replace('天气: ', '');
                        // 检查是否已经有emoji在显示
                        const existingEmojis = document.querySelectorAll('.falling-emoji');
                        if (existingEmojis.length === 0) {
                            if (remoteWeatherData) {
                                console.log('合并显示本地和远程天气emoji');
                                startFallingEmojis(localWeatherText, remoteWeatherData.description);
                            } else {
                                console.log('显示本地天气emoji');
                                startFallingEmojis(localWeatherText);
                            }
                        } else {
                            console.log('已有emoji在显示，跳过重新初始化');
                        }
                    }
                }, 1000);
                
                updateStatus('已连接');
            });

            call.on('close', () => {
                console.log('呼叫已关闭');
                // 关闭数据通道
                if (weatherDataConnection) {
                    weatherDataConnection.close();
                    weatherDataConnection = null;
                }
                isConnectionEstablished = false;
                // 移除所有远程视频元素
                const videoGrid = document.querySelector('.video-grid');
                const remoteWrappers = videoGrid.querySelectorAll('.video-wrapper:not(:first-child)');
                remoteWrappers.forEach(wrapper => wrapper.remove());
                
                // 重新启用呼叫按钮
                callButton.disabled = false;
                updateStatus('通话已结束');
            });

            call.on('error', (err) => {
                console.error('呼叫错误:', err);
                // 重新启用呼叫按钮
                callButton.disabled = false;
                updateStatus('呼叫失败: ' + err.message);
            });
        });

        // 添加 Peer 连接事件监听
        peer.on('connection', (conn) => {
            console.log('收到新的数据连接');
            if (conn.metadata && conn.metadata.type === 'weather') {
                console.log('收到天气数据连接');
                weatherDataConnection = conn;
                
                conn.on('open', () => {
                    console.log('天气数据连接已建立');
                    isConnectionEstablished = true;
                    // 发送天气数据
                    sendWeatherData();
                });
                
                conn.on('data', (data) => {
                    try {
                        console.log('收到原始数据:', data);
                        let weatherData;
                        if (data instanceof ArrayBuffer) {
                            const decoder = new TextDecoder();
                            const text = decoder.decode(data);
                            console.log('转换后的数据:', text);
                            weatherData = JSON.parse(text);
                        } else {
                            weatherData = JSON.parse(data);
                        }
                        console.log('解析后的天气数据:', weatherData);
                        if (weatherData.type === 'weather') {
                            remoteWeatherData = weatherData;
                            console.log('更新远程天气显示:', weatherData);
                            // 立即更新天气显示
                            const remoteWeatherDisplay = document.querySelector('.weather-display.remote');
                            if (remoteWeatherDisplay) {
                                remoteWeatherDisplay.querySelector('.temperature').textContent = `温度: ${weatherData.temperature}`;
                                remoteWeatherDisplay.querySelector('.description').textContent = `天气: ${weatherData.description}`;
                                remoteWeatherDisplay.querySelector('.humidity').textContent = `湿度: ${weatherData.humidity}`;
                                remoteWeatherDisplay.querySelector('.wind').textContent = `风速: ${weatherData.windSpeed} m/s`;
                            }
                        } else {
                            console.log('收到非天气数据:', weatherData);
                        }
                    } catch (error) {
                        console.error('解析远程天气数据失败:', error);
                    }
                });
                
                conn.on('error', (error) => {
                    console.error('数据连接错误:', error);
                });
                
                conn.on('close', () => {
                    console.log('数据连接已关闭');
                    weatherDataConnection = null;
                    isConnectionEstablished = false;
                });
            }
        });

        // 连接状态处理
        peer.on('open', (id) => {
            console.log('Peer 连接成功，ID:', id);
            connectionStatus.textContent = '已连接到服务器';
            connectionStatus.className = 'status-container connected';
            initLocalStream();
        });

        peer.on('error', (err) => {
            console.error('Peer 连接错误:', err);
            connectionStatus.textContent = '连接服务器失败: ' + err.message;
            connectionStatus.className = 'status-container disconnected';
        });

        peer.on('disconnected', () => {
            console.log('Peer 断开连接');
            connectionStatus.textContent = '服务器连接已断开';
            connectionStatus.className = 'status-container disconnected';
        });

        peer.on('close', () => {
            console.log('Peer 连接关闭');
            connectionStatus.textContent = '服务器连接已关闭';
            connectionStatus.className = 'status-container disconnected';
        });

        // Agora 配置
        const APP_ID = 'ad04eb6b99304baab3d0bb9e313982da';
        const APP_CERTIFICATE = '4b37f2aa134b47588c3b7ff4f8d27235';
        
        // 创建 Agora 客户端
        const client = AgoraRTC.createClient({ mode: 'rtc', codec: 'vp8' });
        
        // 获取 DOM 元素
        const joinButton = document.getElementById('joinButton');
        const leaveButton = document.getElementById('leaveButton');
        const statusElement = document.getElementById('status');
        const outputCanvas = document.getElementById('outputCanvas');
        const ctx = outputCanvas.getContext('2d');

        // 设置画布尺寸
        function setCanvasSize() {
            const videoWrapper = outputCanvas.parentElement;
            outputCanvas.width = videoWrapper.offsetWidth;
            outputCanvas.height = videoWrapper.offsetHeight;
        }

        // 初始化 MediaPipe Selfie Segmentation
        const localSelfieSegmentation = new SelfieSegmentation({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`;
            }
        });

        const remoteSelfieSegmentation = new SelfieSegmentation({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`;
            }
        });

        // 设置本地实例选项
        localSelfieSegmentation.setOptions({
            modelSelection: 1, // 使用更精确的模型
            selfieMode: false, // 关闭自拍模式
        });

        // 设置远程实例选项
        remoteSelfieSegmentation.setOptions({
            modelSelection: 0, // 使用更轻量级的模型
            selfieMode: false, // 关闭自拍模式
        });

        // 创建本地遮罩画布
        const localMaskCanvas = document.createElement('canvas');
        localMaskCanvas.style.display = 'none';
        document.body.appendChild(localMaskCanvas);
        const localMaskCtx = localMaskCanvas.getContext('2d');

        // 创建远程遮罩画布
        const remoteMaskCanvas = document.createElement('canvas');
        remoteMaskCanvas.style.display = 'none';
        document.body.appendChild(remoteMaskCanvas);
        const remoteMaskCtx = remoteMaskCanvas.getContext('2d');

        // 本地视频处理回调
        localSelfieSegmentation.onResults((results) => {
            if (!results.segmentationMask) return;

            // 设置本地遮罩画布尺寸
            localMaskCanvas.width = results.segmentationMask.width;
            localMaskCanvas.height = results.segmentationMask.height;

            // 绘制遮罩，禁用镜像处理
            localMaskCtx.drawImage(results.segmentationMask, 0, 0, localMaskCanvas.width, localMaskCanvas.height);

            // 更新处理后的视频流
            processedLocalStream = outputCanvas.captureStream(30);
        });

        // 远程视频处理回调
        remoteSelfieSegmentation.onResults((results) => {
            if (!results.segmentationMask) return;

            // 设置远程遮罩画布尺寸
            remoteMaskCanvas.width = results.segmentationMask.width;
            remoteMaskCanvas.height = results.segmentationMask.height;

            // 绘制遮罩，禁用镜像处理
            remoteMaskCtx.drawImage(results.segmentationMask, 0, 0, remoteMaskCanvas.width, remoteMaskCanvas.height);

            // 更新处理后的视频流
            const remoteCanvas = document.getElementById('remoteOutputCanvas');
            if (remoteCanvas) {
                processedRemoteStream = remoteCanvas.captureStream(30);
            }
        });
        
        // 本地轨道
        let localTracks = [];
        let remoteUsers = {};
        
        // 更新状态显示
        function updateStatus(message) {
            statusElement.textContent = message;
        }
        
        // 初始化本地音视频轨道
        async function initLocalTracks() {
            try {
                // 创建本地音视频轨道
                localTracks = await AgoraRTC.createMicrophoneAndCameraTracks();
                
                // 播放本地视频
                localTracks[1].play(localVideo);
                
                // 开始处理视频帧
                localVideo.onloadedmetadata = () => {
                    processFrame();
                };
                
                updateStatus("本地视频已就绪，点击加入通话开始视频聊天");
                console.log("成功初始化本地音视频轨道");
            } catch (error) {
                console.error("初始化本地音视频轨道失败:", error);
                updateStatus("无法访问摄像头或麦克风，请确保已授予相应权限。");
            }
        }
        
        // 加入频道
        async function joinChannel() {
            try {
                // 生成随机频道名
                const channelName = 'test-channel';
                
                // 加入频道
                await client.join(APP_ID, channelName, null, null);
                
                // 发布本地轨道
                await client.publish(localTracks);
                
                // 更新按钮状态
                joinButton.disabled = true;
                leaveButton.disabled = false;
                
                updateStatus("已加入通话，等待其他用户加入...");
                console.log("成功加入频道");
            } catch (error) {
                console.error("加入频道失败:", error);
                updateStatus("加入频道失败，请重试");
            }
        }
        
        // 离开频道
        async function leaveChannel() {
            try {
                // 停止所有本地轨道
                for (let track of localTracks) {
                    track.stop();
                    track.close();
                }
                
                // 离开频道
                await client.leave();
                
                // 更新按钮状态
                joinButton.disabled = false;
                leaveButton.disabled = true;
                
                // 清空远程视频
                remoteVideo.srcObject = null;
                
                updateStatus("已离开通话");
                console.log("成功离开频道");
            } catch (error) {
                console.error("离开频道失败:", error);
                updateStatus("离开频道失败，请重试");
            }
        }
        
        // 设置远程用户处理
        client.on('user-published', async (user, mediaType) => {
            await client.subscribe(user, mediaType);
            
            if (mediaType === 'video') {
                user.videoTrack.play(remoteVideo);
                updateStatus("其他用户已加入通话");
            }
            
            if (mediaType === 'audio') {
                user.audioTrack.play();
            }
        });
        
        client.on('user-unpublished', (user) => {
            remoteVideo.srcObject = null;
            updateStatus("其他用户已离开通话");
        });
        
        client.on('user-joined', (user) => {
            updateStatus("其他用户已加入通话");
        });
        
        client.on('user-left', (user) => {
            updateStatus("其他用户已离开通话");
        });
        
        // 添加按钮事件监听
        joinButton.addEventListener('click', joinChannel);
        leaveButton.addEventListener('click', leaveChannel);
        
        // 页面加载时初始化本地音视频轨道
        initLocalTracks();

        // 创建双缓冲画布
        const offscreenCanvas = document.createElement('canvas');
        const offscreenCtx = offscreenCanvas.getContext('2d');

        // 处理远程视频帧
        let lastRemoteProcessTime = 0;
        let isRemoteProcessing = false;
        const REMOTE_PROCESS_INTERVAL = 100; // 降低处理间隔

        async function processRemoteFrame() {
            const remoteVideo = document.querySelector('.video-wrapper:not(:first-child) video');
            const remoteCanvas = document.getElementById('remoteOutputCanvas');
            
            if (!remoteVideo || !remoteVideo.videoWidth || !remoteCanvas || isRemoteProcessing) {
                return;
            }

            const now = Date.now();
            if (now - lastRemoteProcessTime < REMOTE_PROCESS_INTERVAL) {
                return;
            }

            isRemoteProcessing = true;
            lastRemoteProcessTime = now;

            try {
                // 设置远程画布尺寸
                const videoWrapper = remoteCanvas.parentElement;
                remoteCanvas.width = videoWrapper.offsetWidth;
                remoteCanvas.height = videoWrapper.offsetHeight;

                // 绘制视频到画布
                const remoteCtx = remoteCanvas.getContext('2d');
                remoteCtx.clearRect(0, 0, remoteCanvas.width, remoteCanvas.height);
                remoteCtx.save();
                remoteCtx.drawImage(remoteVideo, 0, 0, remoteCanvas.width, remoteCanvas.height);
                remoteCtx.restore();

                // 发送到远程 MediaPipe 处理
                await remoteSelfieSegmentation.send({ image: remoteCanvas });
            } catch (error) {
                console.error('处理远程视频帧失败:', error);
            } finally {
                isRemoteProcessing = false;
            }
        }

        // 更新合照取景框
        function updatePhotoFrame() {
            const photoFrame = document.querySelector('.photo-frame');
            const photoFrameCanvas = document.getElementById('photoCanvas');
            const localCanvas = document.getElementById('outputCanvas');
            const remoteCanvas = document.getElementById('remoteOutputCanvas');
            
            // 设置画布尺寸
            photoFrameCanvas.width = photoFrame.offsetWidth;
            photoFrameCanvas.height = photoFrame.offsetHeight;
            offscreenCanvas.width = photoFrameCanvas.width;
            offscreenCanvas.height = photoFrameCanvas.height;
            
            // 清除画布并设置透明背景
            offscreenCtx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
            offscreenCtx.fillStyle = 'rgba(0, 0, 0, 0)';
            offscreenCtx.fillRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
            
            // 设置合成模式
            offscreenCtx.globalCompositeOperation = 'source-over';
            
            // 检查是否有远程用户连接
            const remoteVideo = document.querySelector('.video-wrapper:not(:first-child) video');
            const hasRemoteUser = remoteVideo !== null;
            
            // 更新天气显示
            updateWeatherDisplay(hasRemoteUser);
            
            if (hasRemoteUser) {
                // 两个用户都在线，并排显示
                // 确定本地用户是否为发起方
                const isCaller = callButton.disabled && peerInput.value.trim() !== ''; // 如果呼叫按钮被禁用且输入框有值，说明是发起方
                
                // 设置视频显示区域尺寸
                const displayWidth = offscreenCanvas.width / 2 - 10; // 减小间距，增大显示区域
                const displayHeight = offscreenCanvas.height * 0.9; // 增大高度比例
                
                // 计算垂直居中的位置
                const verticalOffset = (offscreenCanvas.height - displayHeight) / 2;
                
                // 处理本地视频
                if (localCanvas && localCanvas.width > 0 && localMaskCanvas) {
                    try {
                        // 计算视频原始比例
                        const videoAspectRatio = localCanvas.width / localCanvas.height;
                        const displayAspectRatio = displayWidth / displayHeight;
                        
                        let drawWidth, drawHeight, drawX, drawY;
                        
                        if (videoAspectRatio > displayAspectRatio) {
                            // 视频比显示区域宽，以宽度为基准
                            drawWidth = displayWidth;
                            drawHeight = displayWidth / videoAspectRatio;
                            drawX = isCaller ? 20 : offscreenCanvas.width / 2 + 20;
                            drawY = verticalOffset + (displayHeight - drawHeight) / 2;
                        } else {
                            // 视频比显示区域高，以高度为基准
                            drawHeight = displayHeight;
                            drawWidth = displayHeight * videoAspectRatio;
                            drawX = isCaller ? 20 + (displayWidth - drawWidth) / 2 : 
                                             offscreenCanvas.width / 2 + 20 + (displayWidth - drawWidth) / 2;
                            drawY = verticalOffset;
                        }
                        
                        // 创建临时画布用于处理本地视频
                        const tempLocalCanvas = document.createElement('canvas');
                        tempLocalCanvas.width = drawWidth;
                        tempLocalCanvas.height = drawHeight;
                        const tempLocalCtx = tempLocalCanvas.getContext('2d');
                        
                        // 绘制本地视频到临时画布，保持原始比例
                        tempLocalCtx.drawImage(localCanvas, 0, 0, drawWidth, drawHeight);
                        
                        // 应用遮罩
                        tempLocalCtx.globalCompositeOperation = 'destination-in';
                        tempLocalCtx.drawImage(localMaskCanvas, 0, 0, drawWidth, drawHeight);
                        
                        // 绘制到合照取景框，保持垂直居中
                        offscreenCtx.globalCompositeOperation = 'source-over';
                        offscreenCtx.drawImage(tempLocalCanvas, drawX, drawY);
                    } catch (error) {
                        console.error('处理本地视频失败:', error);
                    }
                }
                
                // 处理远程视频
                if (remoteCanvas && remoteCanvas.width > 0 && remoteMaskCanvas) {
                    try {
                        // 计算视频原始比例
                        const videoAspectRatio = remoteCanvas.width / remoteCanvas.height;
                        const displayAspectRatio = displayWidth / displayHeight;
                        
                        let drawWidth, drawHeight, drawX, drawY;
                        
                        if (videoAspectRatio > displayAspectRatio) {
                            // 视频比显示区域宽，以宽度为基准
                            drawWidth = displayWidth;
                            drawHeight = displayWidth / videoAspectRatio;
                            drawX = isCaller ? offscreenCanvas.width / 2 + 20 : 20;
                            drawY = verticalOffset + (displayHeight - drawHeight) / 2;
                        } else {
                            // 视频比显示区域高，以高度为基准
                            drawHeight = displayHeight;
                            drawWidth = displayHeight * videoAspectRatio;
                            drawX = isCaller ? offscreenCanvas.width / 2 + 20 + (displayWidth - drawWidth) / 2 : 
                                             20 + (displayWidth - drawWidth) / 2;
                            drawY = verticalOffset;
                        }
                        
                        // 创建临时画布用于处理远程视频
                        const tempRemoteCanvas = document.createElement('canvas');
                        tempRemoteCanvas.width = drawWidth;
                        tempRemoteCanvas.height = drawHeight;
                        const tempRemoteCtx = tempRemoteCanvas.getContext('2d');
                        
                        // 绘制远程视频到临时画布，保持原始比例
                        tempRemoteCtx.drawImage(remoteCanvas, 0, 0, drawWidth, drawHeight);
                        
                        // 应用遮罩
                        tempRemoteCtx.globalCompositeOperation = 'destination-in';
                        tempRemoteCtx.drawImage(remoteMaskCanvas, 0, 0, drawWidth, drawHeight);
                        
                        // 绘制到合照取景框，保持垂直居中
                        offscreenCtx.globalCompositeOperation = 'source-over';
                        offscreenCtx.drawImage(tempRemoteCanvas, drawX, drawY);
                    } catch (error) {
                        console.error('处理远程视频失败:', error);
                    }
                }
                
                // 添加用户标签
                offscreenCtx.fillStyle = 'white';
                offscreenCtx.font = '20px Arial'; // 增大字体大小
                offscreenCtx.textAlign = 'center';
                const leftLabel = isCaller ? '发起方' : '接收方';
                const rightLabel = isCaller ? '接收方' : '发起方';
                offscreenCtx.fillText(leftLabel, offscreenCanvas.width / 4, offscreenCanvas.height - 20);
                offscreenCtx.fillText(rightLabel, offscreenCanvas.width * 3 / 4, offscreenCanvas.height - 20);
            } else {
                // 只有本地用户，居中显示
                if (localCanvas && localCanvas.width > 0 && localMaskCanvas) {
                    try {
                        // 设置显示区域尺寸
                        const displayWidth = offscreenCanvas.width * 0.8; // 增大宽度比例
                        const displayHeight = offscreenCanvas.height * 0.9; // 增大高度比例
                        
                        // 计算视频原始比例
                        const videoAspectRatio = localCanvas.width / localCanvas.height;
                        const displayAspectRatio = displayWidth / displayHeight;
                        
                        let drawWidth, drawHeight, drawX, drawY;
                        
                        if (videoAspectRatio > displayAspectRatio) {
                            // 视频比显示区域宽，以宽度为基准
                            drawWidth = displayWidth;
                            drawHeight = displayWidth / videoAspectRatio;
                            drawX = (offscreenCanvas.width - drawWidth) / 2;
                            drawY = (offscreenCanvas.height - drawHeight) / 2;
                        } else {
                            // 视频比显示区域高，以高度为基准
                            drawHeight = displayHeight;
                            drawWidth = displayHeight * videoAspectRatio;
                            drawX = (offscreenCanvas.width - drawWidth) / 2;
                            drawY = (offscreenCanvas.height - drawHeight) / 2;
                        }
                        
                        // 创建临时画布用于处理本地视频
                        const tempLocalCanvas = document.createElement('canvas');
                        tempLocalCanvas.width = drawWidth;
                        tempLocalCanvas.height = drawHeight;
                        const tempLocalCtx = tempLocalCanvas.getContext('2d');
                        
                        // 绘制本地视频到临时画布，保持原始比例
                        tempLocalCtx.drawImage(localCanvas, 0, 0, drawWidth, drawHeight);
                        
                        // 应用遮罩
                        tempLocalCtx.globalCompositeOperation = 'destination-in';
                        tempLocalCtx.drawImage(localMaskCanvas, 0, 0, drawWidth, drawHeight);
                        
                        // 绘制到合照取景框，保持居中
                        offscreenCtx.globalCompositeOperation = 'source-over';
                        offscreenCtx.drawImage(tempLocalCanvas, drawX, drawY);
                        
                        // 添加用户标签
                        offscreenCtx.fillStyle = 'white';
                        offscreenCtx.font = '20px Arial'; // 增大字体大小
                        offscreenCtx.textAlign = 'center';
                        offscreenCtx.fillText('本地用户', offscreenCanvas.width / 2, offscreenCanvas.height - 20);
                    } catch (error) {
                        console.error('处理本地视频失败:', error);
                    }
                }
            }
            
            // 将离屏画布内容复制到主画布
            const ctx = photoFrameCanvas.getContext('2d');
            ctx.clearRect(0, 0, photoFrameCanvas.width, photoFrameCanvas.height);
            ctx.fillStyle = 'rgba(0, 0, 0, 0)';
            ctx.fillRect(0, 0, photoFrameCanvas.width, photoFrameCanvas.height);
            ctx.globalCompositeOperation = 'source-over';
            ctx.drawImage(offscreenCanvas, 0, 0);
        }

        // 天气动画对象
        const weatherAnimations = {
            init() {
                this.container = document.getElementById('weather-animations');
                this.animations = new Map();
                console.log('天气动画容器已初始化:', this.container);
            },

            start(weatherType) {
                console.log('开始天气动画:', weatherType);
                this.stop();
                const method = this[weatherType];
                if (method) method.call(this);
            },

            stop() {
                console.log('停止所有天气动画');
                this.animations.forEach(animation => {
                    if (animation.interval) clearInterval(animation.interval);
                    if (animation.element) animation.element.remove();
                });
                this.animations.clear();
                
                // 移除雾效果
                const fog = document.querySelector('.weather-fog');
                if (fog) fog.remove();
            },

            cloudy() {
                console.log('创建多云动画');
                const cloud = document.createElement('div');
                cloud.className = 'weather-cloud';
                this.container.appendChild(cloud);

                let x = 0;
                let y = 25;
                const speed = 1;
                const maxX = this.container.offsetWidth - 100;
                const maxY = this.container.offsetHeight / 2;

                const interval = setInterval(() => {
                    x += speed;
                    if (x > maxX) {
                        x = 0;
                    }
                    cloud.style.left = x + 'px';
                    cloud.style.top = y + '%';
                }, 50);

                this.animations.set('cloudy', { element: cloud, interval });
            },

            rainy() {
                console.log('创建下雨动画');
                const rain = document.createElement('div');
                rain.className = 'weather-rain';
                this.container.appendChild(rain);

                const drops = [];
                for (let i = 0; i < 20; i++) {
                    const drop = document.createElement('div');
                    drop.className = 'weather-drop';
                    rain.appendChild(drop);
                    drops.push({
                        element: drop,
                        x: Math.random() * this.container.offsetWidth,
                        y: Math.random() * this.container.offsetHeight,
                        speed: 3 + Math.random() * 2
                    });
                }

                const interval = setInterval(() => {
                    drops.forEach(drop => {
                        drop.y += drop.speed;
                        if (drop.y > this.container.offsetHeight) {
                            drop.y = 0;
                            drop.x = Math.random() * this.container.offsetWidth;
                        }
                        drop.element.style.transform = `translate(${drop.x}px, ${drop.y}px)`;
                    });
                }, 50);

                this.animations.set('rainy', { element: rain, interval });
            },

            snowy() {
                console.log('创建下雪动画');
                const snow = document.createElement('div');
                snow.className = 'weather-snow';
                this.container.appendChild(snow);

                const flakes = [];
                for (let i = 0; i < 15; i++) {
                    const flake = document.createElement('div');
                    flake.className = 'weather-flake';
                    flake.style.backgroundImage = `url(${i % 2 === 0 ? '雪).png' : '雪花.png'})`;
                    snow.appendChild(flake);
                    flakes.push({
                        element: flake,
                        x: Math.random() * this.container.offsetWidth,
                        y: Math.random() * this.container.offsetHeight,
                        speed: 1 + Math.random() * 2,
                        sway: Math.random() * 2 - 1,
                        rotation: 0,
                        rotationSpeed: (Math.random() - 0.5) * 0.1
                    });
                }

                const interval = setInterval(() => {
                    flakes.forEach(flake => {
                        flake.y += flake.speed;
                        flake.x += flake.sway;
                        flake.rotation += flake.rotationSpeed;
                        if (flake.y > this.container.offsetHeight) {
                            flake.y = 0;
                            flake.x = Math.random() * this.container.offsetWidth;
                        }
                        if (flake.x < 0 || flake.x > this.container.offsetWidth) {
                            flake.sway *= -1;
                        }
                        flake.element.style.transform = `translate(${flake.x}px, ${flake.y}px) rotate(${flake.rotation}rad)`;
                    });
                }, 50);

                this.animations.set('snowy', { element: snow, interval });
            },

            sunny() {
                console.log('创建晴天动画');
                const sun = document.createElement('div');
                sun.className = 'glowing-sun';
                sun.style.setProperty('--sun-size', '60px');
                
                const core = document.createElement('div');
                core.className = 'sun-core';
                
                const halo = document.createElement('div');
                halo.className = 'sun-halo';
                
                // 创建多个随机光斑
                for (let i = 0; i < 5; i++) {
                    const lightSpot = document.createElement('div');
                    lightSpot.className = 'light-spot';
                    // 随机位置
                    lightSpot.style.left = `${Math.random() * 80 + 10}%`;
                    lightSpot.style.top = `${Math.random() * 80 + 10}%`;
                    // 随机延迟
                    lightSpot.style.animationDelay = `${Math.random() * 3}s`;
                    core.appendChild(lightSpot);
                }
                
                sun.appendChild(core);
                sun.appendChild(halo);
                this.container.appendChild(sun);

                // 设置太阳位置
                sun.style.left = `${this.container.offsetWidth / 2}px`;
                sun.style.top = `${this.container.offsetHeight / 2}px`;

                this.animations.set('sunny', { element: sun });
            },

            foggy() {
                console.log('创建雾效果');
                const fog = document.createElement('div');
                fog.className = 'weather-fog';
                this.container.appendChild(fog);
                this.animations.set('foggy', { element: fog });
            }
        };

        // 初始化天气动画
        weatherAnimations.init();

        // 修改updateWeatherDisplay函数
        function updateWeatherDisplay(hasRemoteUser) {
            console.log('更新天气显示，是否有远程用户:', hasRemoteUser);
            
            // 获取本地天气显示元素
            let localWeatherDisplay = document.querySelector('.weather-display.local');
            if (!localWeatherDisplay) {
                console.log('创建本地天气显示元素');
                localWeatherDisplay = document.createElement('div');
                localWeatherDisplay.className = 'weather-display local';
                localWeatherDisplay.innerHTML = `
                    <div class="title">我的天气</div>
                    <div class="content">
                        <div class="temperature">加载中...</div>
                        <div class="description">加载中...</div>
                        <div class="humidity">加载中...</div>
                        <div class="wind">等待数据...</div>
                    </div>
                `;
                document.querySelector('.photo-frame').appendChild(localWeatherDisplay);

                // 立即获取并显示天气信息
                try {
                    const geoData = JSON.parse(localStorage.getItem('geoData'));
                    if (geoData) {
                        console.log('立即获取本地天气');
                        getWeather(geoData.latitude, geoData.longitude).then(weather => {
                            if (weather) {
                                localWeatherDisplay.querySelector('.temperature').textContent = `温度: ${weather.temperature}`;
                                localWeatherDisplay.querySelector('.description').textContent = `天气: ${weather.description}`;
                                localWeatherDisplay.querySelector('.humidity').textContent = `湿度: ${weather.humidity}`;
                                localWeatherDisplay.querySelector('.wind').textContent = `风速: ${weather.windSpeed} m/s`;
                                
                                // 如果双方已连接，则合并显示双方的天气emoji
                                if (hasRemoteUser && remoteWeatherData) {
                                    console.log('双方已连接，开始合并显示emoji');
                                    startFallingEmojis(weather.description, remoteWeatherData.description);
                                } else {
                                    console.log('单方显示emoji');
                                    startFallingEmojis(weather.description);
                                }
                            }
                        });
                    }
                } catch (error) {
                    console.error('获取本地天气失败:', error);
                }
            }

            // 获取远程天气显示元素
            let remoteWeatherDisplay = document.querySelector('.weather-display.remote');
            if (hasRemoteUser && !remoteWeatherDisplay) {
                console.log('创建远程天气显示元素');
                remoteWeatherDisplay = document.createElement('div');
                remoteWeatherDisplay.className = 'weather-display remote';
                remoteWeatherDisplay.innerHTML = `
                    <div class="title">对方天气</div>
                    <div class="content">
                        <div class="temperature">等待数据...</div>
                        <div class="description">等待数据...</div>
                        <div class="humidity">等待数据...</div>
                        <div class="wind">等待数据...</div>
                    </div>
                `;
                document.querySelector('.photo-frame').appendChild(remoteWeatherDisplay);
            } else if (!hasRemoteUser && remoteWeatherDisplay) {
                console.log('移除远程天气显示元素');
                remoteWeatherDisplay.remove();
                remoteWeatherData = null;
            }

            // 更新远程天气
            if (hasRemoteUser && remoteWeatherDisplay && remoteWeatherData) {
                console.log('更新远程天气显示:', remoteWeatherData);
                remoteWeatherDisplay.querySelector('.temperature').textContent = `温度: ${remoteWeatherData.temperature}`;
                remoteWeatherDisplay.querySelector('.description').textContent = `天气: ${remoteWeatherData.description}`;
                remoteWeatherDisplay.querySelector('.humidity').textContent = `湿度: ${remoteWeatherData.humidity}`;
                remoteWeatherDisplay.querySelector('.wind').textContent = `风速: ${remoteWeatherData.windSpeed} m/s`;

                // 获取本地天气描述
                const localWeather = document.querySelector('.weather-display.local .description');
                if (localWeather) {
                    const localWeatherText = localWeather.textContent.replace('天气: ', '');
                    console.log('开始合并显示天气emoji:', { local: localWeatherText, remote: remoteWeatherData.description });
                    // 确保在更新emoji之前不会清除现有的emoji
                    const existingEmojis = document.querySelectorAll('.falling-emoji');
                    if (existingEmojis.length === 0) {
                        startFallingEmojis(localWeatherText, remoteWeatherData.description);
                    }
                }
            }
            
            // 更新本地天气显示后，同时更新背景emoji
            if (localWeatherDisplay) {
                const localWeatherText = localWeatherDisplay.querySelector('.description').textContent.replace('天气: ', '');
                const localVideoWrapper = document.querySelector('.video-wrapper:first-child');
                if (localVideoWrapper) {
                    updateVideoBackgroundEmoji(localVideoWrapper, localWeatherText);
                }
            }
        }

        // 修改startCombinedFallingEmojis函数
        function startCombinedFallingEmojis(localWeather, remoteWeather) {
            console.log('开始合并显示天气emoji:', { local: localWeather, remote: remoteWeather });
            
            // 清除之前的定时器和所有现有的emoji
            if (window.fallingEmojisInterval) {
                clearInterval(window.fallingEmojisInterval);
            }
            const existingEmojis = document.querySelectorAll('.falling-emoji');
            existingEmojis.forEach(emoji => emoji.remove());

            const photoFrame = document.querySelector('.photo-frame');
            if (!photoFrame) {
                console.error('未找到photo-frame元素');
                return;
            }

            // 定义天气对应的emoji数组
            const weatherEmojis = {
                sunny: ['☀️', '🌞', '🌈', '🌼', '🌳'],
                rainy: ['🌧️', '☔', '💧', '🌨️', '☂️'],
                snowy: ['❄️', '⛄', '☃️'],
                cloudy: ['☁️', '🌥️', '⛅'],
                other: ['🌫️', '🌀', '⚡']
            };

            // 获取双方天气对应的emoji列表
            const getWeatherType = (weather) => {
                if (weather.includes('晴')) return 'sunny';
                if (weather.includes('雨')) return 'rainy';
                if (weather.includes('雪')) return 'snowy';
                if (weather.includes('云')) return 'cloudy';
                return 'other';
            };

            const localType = getWeatherType(localWeather);
            const remoteType = getWeatherType(remoteWeather);
            console.log('天气类型:', { localType, remoteType });

            // 合并emoji列表并去重
            const combinedEmojis = [...new Set([
                ...weatherEmojis[localType],
                ...weatherEmojis[remoteType]
            ])];
            console.log('合并后的emoji列表:', combinedEmojis);

            // 每0.8秒创建一个新的emoji
            window.fallingEmojisInterval = setInterval(() => {
                // 每次创建4个emoji
                for (let i = 0; i < 4; i++) {
                    const emoji = document.createElement('div');
                    emoji.className = 'falling-emoji';
                    
                    // 从合并后的列表中随机选择emoji
                    const randomEmoji = combinedEmojis[Math.floor(Math.random() * combinedEmojis.length)];
                    emoji.textContent = randomEmoji;
                    
                    // 随机大小，范围更大
                    const size = Math.random() * 40 + 15; // 15-55px
                    emoji.style.fontSize = `${size}px`;
                    
                    // 根据大小调整动画速度
                    const fallDuration = 8 + (size / 8); // 8-14秒
                    const rotationDuration = 4 + (size / 12); // 4-8秒
                    const swayDuration = 3 + (size / 15); // 3-6秒
                    
                    // 随机水平位置，但限制在取景框内
                    const left = Math.random() * 80 + 10; // 10-90%
                    emoji.style.left = `${left}%`;
                    
                    // 随机旋转动画
                    emoji.style.animation = `rotate ${rotationDuration}s linear infinite`;
                    
                    // 随机水平摆动
                    const swayAmount = 50 + Math.random() * 50; // 50-100px
                    emoji.style.transition = `all ${fallDuration}s cubic-bezier(0.4, 0, 0.2, 1), 
                                            left ${swayDuration}s ease-in-out infinite`;
                    
                    // 添加到容器
                    photoFrame.appendChild(emoji);
                    
                    // 强制重排，开始掉落动画
                    emoji.offsetHeight;
                    emoji.style.top = '600px';
                    
                    // 添加水平摆动
                    const swayInterval = setInterval(() => {
                        const currentLeft = parseFloat(emoji.style.left);
                        const newLeft = currentLeft + (Math.random() * 2 - 1) * swayAmount;
                        emoji.style.left = `${Math.max(10, Math.min(90, newLeft))}%`;
                    }, swayDuration * 1000);
                    
                    // 动画结束后移除元素
                    setTimeout(() => {
                        clearInterval(swayInterval);
                        emoji.remove();
                    }, fallDuration * 1000);
                }
            }, 800);
        }

        // 修改定期更新天气的函数
        async function updateWeatherPeriodically() {
            console.log('开始定期更新天气...');
            const geoData = JSON.parse(localStorage.getItem('geoData'));
            if (geoData) {
                console.log('获取本地地理位置:', geoData);
                try {
                const weather = await getWeather(geoData.latitude, geoData.longitude);
                if (weather) {
                    const weatherData = {
                        type: 'weather',
                        temperature: weather.temperature,
                        description: weather.description,
                        humidity: weather.humidity,
                        windSpeed: weather.windSpeed
                    };
                    console.log('准备发送更新的天气数据:', weatherData);
                    
                    // 如果当前有活跃的数据连接，发送更新的天气信息
                    if (weatherDataConnection && weatherDataConnection.open) {
                        weatherDataConnection.send(JSON.stringify(weatherData));
                        console.log('已发送更新的天气信息');
                    } else {
                        console.log('没有活跃的数据连接，无法发送更新');
                    }
                }
                } catch (error) {
                    console.error('更新天气信息失败:', error);
                }
            }
        }

        // 增加更新间隔到10分钟，减少API调用频率
        setInterval(updateWeatherPeriodically, 10 * 60 * 1000);

        // 修改合照取景框更新间隔
        const updateInterval = setInterval(() => {
            updatePhotoFrame();
        }, 200); // 增加更新间隔到200ms以降低处理频率

        // 获取用户地理位置
        function getLocation() {
            return new Promise((resolve, reject) => {
            if (!navigator.geolocation) {
                    console.warn('浏览器不支持地理位置功能');
                    resolve({ latitude: 23.129163, longitude: 113.264435 }); // 默认广州坐标
                return;
            }

            const options = {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 0
            };

            navigator.geolocation.getCurrentPosition(
                (position) => {
                        console.log('获取到地理位置:', {
                        latitude: position.coords.latitude,
                        longitude: position.coords.longitude,
                            accuracy: position.coords.accuracy + '米'
                        });
                        resolve({
                            latitude: position.coords.latitude,
                            longitude: position.coords.longitude
                        });
                },
                (error) => {
                        console.error('获取地理位置失败:', error.message);
                    switch(error.code) {
                        case error.PERMISSION_DENIED:
                                console.warn('用户拒绝了地理位置请求');
                            break;
                        case error.POSITION_UNAVAILABLE:
                                console.warn('位置信息不可用');
                            break;
                        case error.TIMEOUT:
                                console.warn('获取位置超时');
                            break;
                        default:
                                console.warn('获取位置时发生未知错误');
                    }
                        // 使用默认位置（广州）
                        resolve({ latitude: 23.129163, longitude: 113.264435 });
                },
                options
            );
            });
        }

        // 页面加载时获取地理位置
        window.addEventListener('load', () => {
            getLocation().then(geoData => {
                localStorage.setItem('geoData', JSON.stringify(geoData));
                console.log('地理位置已保存到本地存储:', geoData);
            });
        });

        // 修改startFallingEmojis函数
        function startFallingEmojis(localWeather, remoteWeather = null) {
            console.log('开始显示天气emoji:', { local: localWeather, remote: remoteWeather });
            
            // 清除之前的定时器和所有现有的emoji
            if (window.fallingEmojisInterval) {
                console.log('清除之前的emoji定时器');
                clearInterval(window.fallingEmojisInterval);
            }
            
            const existingEmojis = document.querySelectorAll('.falling-emoji');
            existingEmojis.forEach(emoji => emoji.remove());

            const photoFrame = document.querySelector('.photo-frame');
            if (!photoFrame) {
                console.error('未找到photo-frame元素');
                return;
            }

            // 定义天气对应的emoji数组
            const weatherEmojis = {
                sunny: ['☀️', '🌞', '🌈', '🌼', '🌳'],
                rainy: ['🌧️', '☔', '💧', '🌨️', '☂️'],
                snowy: ['❄️', '⛄', '☃️'],
                cloudy: ['☁️', '🌥️', '⛅'],
                other: ['🌫️', '🌀', '⚡']
            };

            // 获取天气类型对应的emoji列表
            const getWeatherType = (weather) => {
                if (!weather) return 'other';
                if (weather.includes('晴')) return 'sunny';
                if (weather.includes('雨')) return 'rainy';
                if (weather.includes('雪')) return 'snowy';
                if (weather.includes('云')) return 'cloudy';
                return 'other';
            };

            // 获取本地和远程的emoji列表
            const localType = getWeatherType(localWeather);
            const remoteType = getWeatherType(remoteWeather);
            
            // 合并emoji列表并去重
            const combinedEmojis = [...new Set([
                ...weatherEmojis[localType],
                ...weatherEmojis[remoteType]
            ])];
            
            console.log('合并后的emoji列表:', combinedEmojis);

            // 每0.8秒创建一个新的emoji
            window.fallingEmojisInterval = setInterval(() => {
                // 每次创建3个emoji
                for (let i = 0; i < 3; i++) {
                    const emoji = document.createElement('div');
                    emoji.className = 'falling-emoji';
                    
                    // 从合并后的列表中随机选择emoji
                    const randomEmoji = combinedEmojis[Math.floor(Math.random() * combinedEmojis.length)];
                    emoji.textContent = randomEmoji;
                    
                    // 随机大小
                    const size = Math.random() * 40 + 15; // 15-55px
                    emoji.style.fontSize = `${size}px`;
                    
                    // 根据大小调整动画速度
                    const fallDuration = 8 + (size / 8); // 8-14秒
                    const rotationDuration = 4 + (size / 12); // 4-8秒
                    const swayDuration = 3 + (size / 15); // 3-6秒
                    
                    // 随机水平位置
                    const left = Math.random() * 80 + 10; // 10-90%
                    emoji.style.left = `${left}%`;
                    
                    // 设置动画
                    emoji.style.animation = `rotate ${rotationDuration}s linear infinite`;
                    emoji.style.transition = `all ${fallDuration}s cubic-bezier(0.4, 0, 0.2, 1), 
                                            left ${swayDuration}s ease-in-out infinite`;
                    
                    // 添加到容器
                    photoFrame.appendChild(emoji);
                    
                    // 强制重排，开始掉落动画
                    emoji.offsetHeight;
                    emoji.style.top = '600px';
                    
                    // 添加水平摆动
                    const swayInterval = setInterval(() => {
                        const currentLeft = parseFloat(emoji.style.left);
                        const newLeft = currentLeft + (Math.random() * 2 - 1) * 50;
                        emoji.style.left = `${Math.max(10, Math.min(90, newLeft))}%`;
                    }, swayDuration * 1000);
                    
                    // 动画结束后移除元素
                    setTimeout(() => {
                        clearInterval(swayInterval);
                        emoji.remove();
                    }, fallDuration * 1000);
                }
            }, 800);
        }

        async function updateWeather() {
            try {
                const geoData = JSON.parse(localStorage.getItem('geoData'));
                if (!geoData) {
                    console.warn('未找到地理位置数据，尝试重新获取');
                    const newGeoData = await getLocation();
                    localStorage.setItem('geoData', JSON.stringify(newGeoData));
                    return updateWeather(); // 递归调用以使用新获取的位置
                }

                const weatherData = await getWeather(geoData.latitude, geoData.longitude);
                if (!weatherData) {
                    console.warn('获取天气数据失败，将在1分钟后重试');
                    setTimeout(updateWeather, 60000);
                    return;
                }

                console.log('天气数据更新成功:', weatherData);
                localStorage.setItem('weatherData', JSON.stringify(weatherData));
                
                // 更新天气显示
                const weatherDisplay = document.getElementById('weather-display');
                if (weatherDisplay) {
                    weatherDisplay.textContent = `${weatherData.city} ${weatherData.temp}°C ${weatherData.weather}`;
                }

                // 更新表情动画
                if (typeof startFallingEmojis === 'function') {
                    startFallingEmojis(weatherData.weather);
                }

                // 设置下一次更新
                setTimeout(updateWeather, 300000); // 5分钟更新一次
            } catch (error) {
                console.error('更新天气数据时发生错误:', error);
                setTimeout(updateWeather, 60000); // 发生错误时1分钟后重试
            }
        }

        // 页面加载时启动天气更新
        window.addEventListener('load', () => {
            updateWeather();
        });

        function updateWeatherBackground(localWeather, remoteWeather) {
            const videoWrappers = document.querySelectorAll('.video-wrapper');
            videoWrappers.forEach(wrapper => {
                let background = wrapper.querySelector('.weather-background');
                if (!background) {
                    background = document.createElement('div');
                    background.className = 'weather-background';
                    wrapper.insertBefore(background, wrapper.firstChild);
                }
                
                // Clear existing emojis
                background.innerHTML = '';
                
                // Get emojis for both local and remote weather
                const localEmojis = getWeatherEmojis(localWeather);
                const remoteEmojis = remoteWeather ? getWeatherEmojis(remoteWeather) : [];
                
                // Combine and deduplicate emojis
                const allEmojis = [...new Set([...localEmojis, ...remoteEmojis])];
                
                // Create emoji elements
                allEmojis.forEach(emoji => {
                    const emojiElement = document.createElement('div');
                    emojiElement.className = 'weather-background-emoji';
                    emojiElement.textContent = emoji;
                    emojiElement.style.animationDelay = `${Math.random() * 2}s`;
                    background.appendChild(emojiElement);
                });
            });
        }

        function getWeatherEmojis(weatherText) {
            const weatherEmojis = {
                'Clear': ['☀️', '🌞'],
                'Clouds': ['☁️', '⛅'],
                'Rain': ['🌧️', '🌦️'],
                'Snow': ['🌨️', '❄️'],
                'Thunderstorm': ['⛈️', '🌩️'],
                'Drizzle': ['🌦️', '🌧️'],
                'Mist': ['🌫️', '💨'],
                'Smoke': ['🌫️', '💨'],
                'Haze': ['🌫️', '💨'],
                'Dust': ['🌫️', '💨'],
                'Fog': ['🌫️', '💨'],
                'Sand': ['🌫️', '💨'],
                'Ash': ['🌫️', '💨'],
                'Squall': ['💨', '🌪️'],
                'Tornado': ['🌪️', '🌀'],
                'default': ['🌤️', '🌈']
            };

            const weather = weatherText.toLowerCase();
            for (const [key, emojis] of Object.entries(weatherEmojis)) {
                if (weather.includes(key.toLowerCase())) {
                    return emojis;
                }
            }
            return weatherEmojis.default;
        }

        function updateVideoBackgroundEmoji(videoWrapper, weatherText) {
            console.log('更新视频背景emoji:', { videoWrapper, weatherText });
            
            // 移除现有的背景emoji
            const existingEmoji = videoWrapper.querySelector('.video-background-emoji');
            if (existingEmoji) {
                existingEmoji.remove();
            }

            // 获取天气对应的emoji
            const weatherEmoji = getWeatherEmoji(weatherText);
            console.log('选择的emoji:', weatherEmoji);
            
            // 创建新的背景emoji元素
            const emojiElement = document.createElement('div');
            emojiElement.className = 'video-background-emoji';
            emojiElement.textContent = weatherEmoji;
            
            // 将emoji添加到视频包装器的最前面
            videoWrapper.insertBefore(emojiElement, videoWrapper.firstChild);
            
            console.log('背景emoji已添加');
        }

        function getWeatherEmoji(weatherText) {
            if (!weatherText) return '🌤️';
            
            const weather = weatherText.toLowerCase();
            if (weather.includes('晴')) return '☀️';
            if (weather.includes('雨')) return '🌧️';
            if (weather.includes('雪')) return '❄️';
            if (weather.includes('云')) return '☁️';
            if (weather.includes('雾')) return '🌫️';
            return '🌤️';
        }

        // 修改call.on('stream')处理函数
        call.on('stream', async (remoteStream) => {
            console.log('收到远程视频流');
            
            // 更新本地和远程视频的背景emoji
            const localWeatherDisplay = document.querySelector('.weather-display.local .description');
            const remoteWeatherDisplay = document.querySelector('.weather-display.remote .description');
            
            if (localWeatherDisplay) {
                const localWeatherText = localWeatherDisplay.textContent.replace('天气: ', '');
                console.log('本地天气:', localWeatherText);
                const localVideoWrapper = document.querySelector('.video-wrapper:first-child');
                if (localVideoWrapper) {
                    updateVideoBackgroundEmoji(localVideoWrapper, localWeatherText);
                }
            }
            
            if (remoteWeatherDisplay) {
                const remoteWeatherText = remoteWeatherDisplay.textContent.replace('天气: ', '');
                console.log('远程天气:', remoteWeatherText);
                const remoteVideoWrapper = document.querySelector('.video-wrapper:last-child');
                if (remoteVideoWrapper) {
                    updateVideoBackgroundEmoji(remoteVideoWrapper, remoteWeatherText);
                }
            }
            
            // ... existing code ...
        });

        // 修改weatherDataConnection.on('data')处理函数
        weatherDataConnection.on('data', (data) => {
            try {
                console.log('收到原始数据:', data);
                let weatherData;
                if (data instanceof ArrayBuffer) {
                    const decoder = new TextDecoder();
                    const text = decoder.decode(data);
                    console.log('转换后的数据:', text);
                    weatherData = JSON.parse(text);
                } else {
                    weatherData = JSON.parse(data);
                }
                console.log('解析后的天气数据:', weatherData);
                if (weatherData.type === 'weather') {
                    remoteWeatherData = weatherData;
                    console.log('更新远程天气显示:', weatherData);
                    
                    // 更新远程视频背景emoji
                    const remoteVideoWrapper = document.querySelector('.video-wrapper:last-child');
                    if (remoteVideoWrapper) {
                        updateVideoBackgroundEmoji(remoteVideoWrapper, weatherData.description);
                    }
                    
                    // ... existing code ...
                }
            } catch (error) {
                console.error('解析远程天气数据失败:', error);
            }
        });
        // ... existing code ...

        // 添加初始化背景emoji的函数
        function initializeBackgroundEmojis() {
            console.log('开始初始化背景emoji...');
            
            // 获取本地天气信息
            const localWeatherDisplay = document.querySelector('#local-weather');
            if (!localWeatherDisplay) {
                console.error('未找到本地天气显示元素');
                return;
            }
            
            const localWeather = localWeatherDisplay.textContent;
            console.log('当前本地天气:', localWeather);
            
            // 获取合照取景框容器
            const photoFrame = document.querySelector('.photo-frame');
            if (!photoFrame) {
                console.error('未找到合照取景框容器');
                return;
            }
            
            // 移除现有的背景emoji
            const existingEmoji = photoFrame.querySelector('.video-background-emoji');
            if (existingEmoji) {
                existingEmoji.remove();
            }
            
            // 创建背景emoji元素
            const emojiElement = document.createElement('div');
            emojiElement.className = 'video-background-emoji';
            emojiElement.style.position = 'absolute';
            emojiElement.style.top = '0';
            emojiElement.style.left = '0';
            emojiElement.style.width = '100%';
            emojiElement.style.height = '100%';
            emojiElement.style.display = 'flex';
            emojiElement.style.alignItems = 'center';
            emojiElement.style.justifyContent = 'center';
            emojiElement.style.fontSize = '200px';
            emojiElement.style.opacity = '0.3';
            emojiElement.style.zIndex = '1000';  // 提高z-index确保在视频层上方
            emojiElement.style.pointerEvents = 'none';
            
            // 根据天气设置emoji
            const weatherEmoji = getWeatherEmoji(localWeather);
            emojiElement.textContent = weatherEmoji;
            
            // 将emoji插入到photoFrame的最后面
            photoFrame.appendChild(emojiElement);
            console.log('背景emoji已添加到合照取景框');
        }

        // 更新背景emoji的函数
        function updateWeatherBackground(localWeather, remoteWeather) {
            console.log('更新背景emoji:', { localWeather, remoteWeather });
            
            // 获取合照取景框容器
            const photoFrame = document.querySelector('.photo-frame');
            if (!photoFrame) {
                console.error('未找到合照取景框容器');
                return;
            }
            
            // 移除旧的背景emoji
            const oldEmoji = photoFrame.querySelector('.video-background-emoji');
            if (oldEmoji) {
                oldEmoji.remove();
            }
            
            // 创建新的背景emoji
            const emojiElement = document.createElement('div');
            emojiElement.className = 'video-background-emoji';
            emojiElement.style.position = 'absolute';
            emojiElement.style.top = '0';
            emojiElement.style.left = '0';
            emojiElement.style.width = '100%';
            emojiElement.style.height = '100%';
            emojiElement.style.display = 'flex';
            emojiElement.style.alignItems = 'center';
            emojiElement.style.justifyContent = 'center';
            emojiElement.style.fontSize = '200px';
            emojiElement.style.opacity = '0.3';
            emojiElement.style.zIndex = '1000';  // 提高z-index确保在视频层上方
            emojiElement.style.pointerEvents = 'none';
            
            // 根据天气设置emoji
            const weatherEmoji = getWeatherEmoji(localWeather);
            emojiElement.textContent = weatherEmoji;
            
            // 将emoji插入到photoFrame的最后面
            photoFrame.appendChild(emojiElement);
            console.log('背景emoji已更新');
        }

        // 在页面加载完成后初始化背景emoji
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM加载完成，准备初始化背景emoji...');
            // 延迟一小段时间确保DOM完全加载
            setTimeout(() => {
                initializeBackgroundEmojis();
            }, 1000);
        });

        // 修改视频流处理函数，确保在连接建立后更新背景emoji
        call.on('stream', async (remoteStream) => {
            // ... existing code ...
            
            // 在连接建立后更新背景emoji
            setTimeout(() => {
                const localWeather = document.querySelector('#local-weather').textContent;
                const remoteWeather = document.querySelector('#remote-weather').textContent;
                updateWeatherBackground(localWeather, remoteWeather);
            }, 1000);
            
            // ... existing code ...
        });
        // ... existing code ...

        // 添加地球按钮点击事件
        document.querySelector('.earth-button').addEventListener('click', function() {
            window.location.href = 'home.html';
        });

        // 添加home按钮点击事件
        document.querySelector('.home-button').addEventListener('click', function() {
            window.location.href = 'home.html';
        });

        // 添加拍照功能
        function capturePhoto() {
            console.log('拍照按钮被点击');
            const photoFrame = document.querySelector('.photo-frame');
            const countdownElement = document.querySelector('.capture-countdown');
            const previewElement = document.querySelector('.photo-preview');
            const previewImage = previewElement.querySelector('img');
            const successMessage = document.querySelector('.capture-success');
            
            if (!photoFrame) {
                console.error('未找到photo-frame元素');
                return;
            }
            
            // 显示倒计时
            countdownElement.style.display = 'block';
            let count = 3;
            const countdownInterval = setInterval(() => {
                countdownElement.textContent = count;
                count--;
                if (count < 0) {
                    clearInterval(countdownInterval);
                    countdownElement.style.display = 'none';
                }
            }, 1000);
            
            // 等待3秒，让用户摆好姿势
            setTimeout(async () => {
                try {
                    console.log('开始捕获画面...');
                    
                    // 创建一个临时容器来保存emoji的当前状态
                    const tempContainer = document.createElement('div');
                    tempContainer.style.position = 'absolute';
                    tempContainer.style.width = '100%';
                    tempContainer.style.height = '100%';
                    tempContainer.style.pointerEvents = 'none';
                    tempContainer.style.zIndex = '9999';
                    
                    // 获取所有emoji并保存它们的当前位置
                    const allEmojis = document.querySelectorAll('.falling-emoji, .weather-emoji');
                    const emojiPositions = [];
                    
                    // 首先记录所有emoji的位置
                    allEmojis.forEach(emoji => {
                        const rect = emoji.getBoundingClientRect();
                        const frameRect = photoFrame.getBoundingClientRect();
                        emojiPositions.push({
                            element: emoji,
                            left: rect.left - frameRect.left,
                            top: rect.top - frameRect.top,
                            transform: window.getComputedStyle(emoji).transform
                        });
                    });
                    
                    // 创建一个新的canvas来绘制所有emoji
                    const canvas = document.createElement('canvas');
                    canvas.width = photoFrame.offsetWidth * 2;
                    canvas.height = photoFrame.offsetHeight * 2;
                    const ctx = canvas.getContext('2d');
                    
                    // 先绘制photo-frame的背景
                    const frameCanvas = await html2canvas(photoFrame, {
                        useCORS: true,
                        allowTaint: true,
                        backgroundColor: null,
                        scale: 2,
                        logging: true
                    });
                    
                    ctx.drawImage(frameCanvas, 0, 0);
                    
                    // 然后绘制所有emoji
                    emojiPositions.forEach(pos => {
                        const emojiCanvas = document.createElement('canvas');
                        emojiCanvas.width = pos.element.offsetWidth * 2;
                        emojiCanvas.height = pos.element.offsetHeight * 2;
                        const emojiCtx = emojiCanvas.getContext('2d');
                        
                        // 设置emoji的样式
                        emojiCtx.fillStyle = window.getComputedStyle(pos.element).color;
                        emojiCtx.font = `${pos.element.offsetHeight * 2}px Arial`;
                        emojiCtx.textAlign = 'center';
                        emojiCtx.textBaseline = 'middle';
                        
                        // 绘制emoji
                        emojiCtx.fillText(pos.element.textContent, 
                            emojiCanvas.width / 2, 
                            emojiCanvas.height / 2);
                        
                        // 将emoji绘制到主canvas上
                        ctx.save();
                        ctx.translate(pos.left * 2, pos.top * 2);
                        ctx.transform(...pos.transform.split('matrix(')[1].split(')')[0].split(',').map(Number));
                        ctx.drawImage(emojiCanvas, 0, 0);
                        ctx.restore();
                    });
                    
                    console.log('画面捕获完成，显示预览...');
                    // 显示预览
                    previewImage.src = canvas.toDataURL('image/jpeg', 0.95);
                    previewElement.style.display = 'block';
                    
                    // 添加预览按钮事件监听
                    const saveBtn = previewElement.querySelector('.save-btn');
                    const retryBtn = previewElement.querySelector('.retry-btn');
                    const cancelBtn = previewElement.querySelector('.cancel-btn');
                    
                    saveBtn.onclick = () => {
                        const link = document.createElement('a');
                        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                        link.download = `合影_${timestamp}.jpg`;
                        link.href = previewImage.src;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        
                        // 显示成功消息
                        successMessage.style.display = 'block';
                        setTimeout(() => {
                            successMessage.style.display = 'none';
                        }, 3000);
                        
                        // 隐藏预览
                        previewElement.style.display = 'none';
                    };
                    
                    retryBtn.onclick = () => {
                        previewElement.style.display = 'none';
                        capturePhoto();
                    };
                    
                    cancelBtn.onclick = () => {
                        previewElement.style.display = 'none';
                    };
                    
                } catch (error) {
                    console.error('拍照失败:', error);
                    alert('拍照失败，请重试: ' + error.message);
                }
            }, 3000);
        }

        // 在页面加载完成后初始化拍照按钮
        document.addEventListener('DOMContentLoaded', initializeCaptureButton);

        // 添加背景颜色切换功能
        function changeBackgroundColor(color) {
            const photoFrame = document.getElementById('photoFrame');
            const photoCanvas = document.getElementById('photoCanvas');
            
            if (photoFrame && photoCanvas) {
                // 更新背景颜色
                photoFrame.style.backgroundColor = color;
                photoCanvas.style.backgroundColor = color;
                
                // 更新活动状态
                document.querySelectorAll('.color-option').forEach(opt => {
                    opt.classList.remove('active');
                    if (opt.getAttribute('data-color') === color) {
                        opt.classList.add('active');
                    }
                });
                
                console.log('背景颜色已更改为:', color);
            } else {
                console.error('找不到必要的元素');
            }
        }

        // 初始化颜色选择器
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM加载完成，初始化颜色选择器');
            changeBackgroundColor('#ffffff');
        });
    </script>
    <div class="capture-countdown">3</div>
    <div class="photo-preview">
        <img src="" alt="预览">
        <div class="photo-preview-buttons">
            <button class="save-btn">保存</button>
            <button class="retry-btn">重拍</button>
            <button class="cancel-btn">取消</button>
        </div>
    </div>
    <div class="capture-success">照片已保存！</div>
</body>
</html> 